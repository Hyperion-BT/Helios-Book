<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Helios Programming Language</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="The_Helios_Programming_Language.html"><strong aria-hidden="true">1.</strong> The Helios Programming Language</a></li><li class="chapter-item expanded "><a href="chapter_1/00_Basics_of_Helios.html"><strong aria-hidden="true">2.</strong> Basics of Helios</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1/01_Variables.html"><strong aria-hidden="true">2.1.</strong> Variables</a></li><li class="chapter-item expanded "><a href="chapter_1/02_Builtin_Types.html"><strong aria-hidden="true">2.2.</strong> Builtin Types</a></li><li class="chapter-item expanded "><a href="chapter_1/04_Functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="chapter_1/05_Structs_and_Enums.html"><strong aria-hidden="true">2.4.</strong> Structs and Enums</a></li><li class="chapter-item expanded "><a href="chapter_1/06_Methods_and_Associated_Functions.html"><strong aria-hidden="true">2.5.</strong> Methods and Associated Functions</a></li><li class="chapter-item expanded "><a href="chapter_1/07_Comments_and_Printing.html"><strong aria-hidden="true">2.6.</strong> Comments and Printing</a></li><li class="chapter-item expanded "><a href="chapter_1/08_Control_Flow_and_Printing.html"><strong aria-hidden="true">2.7.</strong> Control Flow and Printing</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2/00_Blockchain_Programming_in_Helios.html"><strong aria-hidden="true">3.</strong> Blockchain Development with Helios</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2/01_The_EUTXO_Model.html"><strong aria-hidden="true">3.1.</strong> The EUTXO Model</a></li><li class="chapter-item expanded "><a href="chapter_2/02_Validator_Scripts.html"><strong aria-hidden="true">3.2.</strong> Validator Scripts</a></li><li class="chapter-item expanded "><a href="chapter_2/03_ScriptContext.html"><strong aria-hidden="true">3.3.</strong> The ScriptContext</a></li><li class="chapter-item expanded "><a href="chapter_2/04_vesting_contract.html"><strong aria-hidden="true">3.4.</strong> Example 1: Vesting Contract</a></li><li class="chapter-item expanded "><a href="chapter_2/05_english_auction.html"><strong aria-hidden="true">3.5.</strong> Example 2: English Auction</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_3/Native_Assets.html"><strong aria-hidden="true">4.</strong> Native Assets</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_3/Value.html"><strong aria-hidden="true">4.1.</strong> Value</a></li><li class="chapter-item expanded "><a href="chapter_3/Signed.html"><strong aria-hidden="true">4.2.</strong> Signed Policy</a></li><li class="chapter-item expanded "><a href="chapter_3/NFT.html"><strong aria-hidden="true">4.3.</strong> NFT</a></li></ol></li><li class="chapter-item expanded "><a href="helios_builtins/helios_builtins.html"><strong aria-hidden="true">5.</strong> Helios Builtins</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="helios_builtins/primitive_types.html"><strong aria-hidden="true">5.1.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="helios_builtins/time_types.html"><strong aria-hidden="true">5.2.</strong> Time Types</a></li><li class="chapter-item expanded "><a href="helios_builtins/cryptography_types.html"><strong aria-hidden="true">5.3.</strong> Cryptography Types</a></li><li class="chapter-item expanded "><a href="helios_builtins/native-asset_types.html"><strong aria-hidden="true">5.4.</strong> Native-Assets Types</a></li><li class="chapter-item expanded "><a href="helios_builtins/transaction_types.html"><strong aria-hidden="true">5.5.</strong> Transaction Types</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Helios Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-helios-programming-language"><a class="header" href="#the-helios-programming-language">The Helios Programming Language</a></h1>
<p><a href="https://github.com/Hyperion-BT/Helios">Helios</a> is a DSL for writing smart contracts on the Cardano blockchain.
It's heavily inspired by Rust, Go and Sway.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<ul>
<li>Helios should be readable by almost any programmer.</li>
<li>There should be one and preferrably only one way to do everything (For example, no trailing commas).</li>
</ul>
<br/>
<pre><code class="language-go  noplaypen">// All Helios programs begin with a script purpose.
spending always_true 

// The 'main' function contains the core validator logic.
func main() -&gt; Bool {
    // Helios is an expression based language
    true
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basics-of-helios"><a class="header" href="#basics-of-helios">Basics of Helios</a></h1>
<p>In this chapter we will cover the basics of the Helios programming language.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="variables"><a class="header" href="#variables">Variables</a></h1>
<p>Variables in Helios are <em>immutable</em>. This means that once a variable is declared, it's value cannot change.</p>
<h2 id="declaring-a-variable"><a class="header" href="#declaring-a-variable">Declaring a Variable</a></h2>
<pre><code class="language-rust  noplaypen">num: Int = 42;
</code></pre>
<p>From the variable declaration above we can tell about <code>num</code>:
1. It is immutable.
2. It's value is <code>42</code>.
3. It's type is <code>Int</code>.</p>
<p><code>Int</code> is the only builtin numeric type in Helios it represents an unbounded integer. See <a href="chapter_1/./02_Builtin_Types.html">Builtin Types</a> for more details.</p>
<h2 id="type-annotations"><a class="header" href="#type-annotations">Type Annotations</a></h2>
<p>A variable declaration must contain a <em>type annotation.</em>, unless it's right-hand side is a literal.
This is done not just for helping the compiler, but also to make Helios code more readable. A few more example of type annotations.</p>
<pre><code class="language-rust  noplaypen">list_of_ints = []Int{1, 1, 2, 3, 5};

// Instead of

list_of_ints: []Int = []Int{1, 1, 2, 3, 5};
</code></pre>
<h2 id="constants"><a class="header" href="#constants">Constants</a></h2>
<p>Helios has support for compile-time constants, constants are declared using the <code>const</code> keyword and must be named in all caps.
Constants in Helios are <em>top-level</em> statements, this means they are declared outside functions like <code>struct</code> definitions,
in Helios top-level statements are not followed by a semicolon (<code>;</code>).</p>
<pre><code class="language-rust  noplaypen">const AGE: Int = 2132
</code></pre>
<p>It's best practice to use <code>const</code> for all top-level assignments and all variables known at compile-time.</p>
<blockquote>
<p><strong>Note</strong>: Constants are statements can only be set to the result of an <code>if</code>/<code>else</code> expression if the <code>if</code>/<code>else</code> expression evaluates to something constant.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="builtin-types"><a class="header" href="#builtin-types">Builtin Types</a></h1>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>Helios has 6 primitive types:</p>
<ul>
<li><code>Int</code> (an unbounded integer)</li>
<li><code>Bool</code> (Boolean <code>true</code> or <code>false</code>)</li>
<li><code>ByteArray</code> (array of bytes)</li>
<li><code>String</code> (fixed-length string)</li>
<li><code>List</code> (linked list)</li>
<li><code>Map</code> (A hashmap)</li>
<li><code>Option</code></li>
</ul>
<h2 id="int"><a class="header" href="#int"><code>Int</code></a></h2>
<hr />
<p>Helios' <code>Int</code> type represents an unbounded integer like Haskell's <code>Integer</code> type.</p>
<pre><code class="language-rust noplaypen">// Helios has support for multiple Integer literal formats
normal_literal: Int = 17;
bits_literal: Int = 0b10001;
hex_literal: Int = 0x11;
idk_literal: Int = 0o121;
</code></pre>
<h2 id="bool"><a class="header" href="#bool"><code>Bool</code></a></h2>
<hr />
<p>The <code>Bool</code> type has two possible values: <code>true</code> or <code>false</code>. Boolean values are typically used for conditional logic or validation, for example in <code>if</code> expressions. Booleans can be negated using the negation operator (<code>!</code>),</p>
<pre><code class="language-rust noplaypen">func returns_false() -&gt; Bool {
    !true
}
</code></pre>
<p>Booleans can also be converted into <code>Int</code>s using the <code>to_int</code> method.</p>
<pre><code class="language-rust noplaypen">x: Int = (true).to_int();  // x == 1
y: Int = (false).to_int(); // y == 0
</code></pre>
<h2 id="bytearray"><a class="header" href="#bytearray"><code>ByteArray</code></a></h2>
<hr />
<p>The <code>ByteArray</code> type as you've likely guessed represents an array of bytes.</p>
<pre><code class="language-rust noplaypen">simple_bytearray: ByteArray = #af2r221ad;
</code></pre>
<p>All most core Helios types including all other primitve types can be converted to a <code>ByteArray</code> using the <code>serialize</code> method.</p>
<pre><code class="language-rust noplaypen">result: ByteArray = (1231).serialize();
</code></pre>
<h2 id="string"><a class="header" href="#string"><code>String</code></a></h2>
<hr />
<p>Helios strings can be declared using double (<code>&quot;</code>) quotes.</p>
<pre><code class="language-ts noplaypen">double_quotes: String = &quot;Wow I did it again&quot;;
</code></pre>
<p>Strings in Helios are of static-length and immutable.
This means a string cannot 'grow' to accomodate more characters after it is declared.
When concatenating strings in Helios a new string is created.</p>
<pre><code class="language-rust noplaypen">string_1: String = &quot;Hel&quot;;
string_2: String = &quot;ios&quot;;
result: String = string_1 + string_2; // &quot;Helios&quot;
</code></pre>
<h2 id="list-a"><a class="header" href="#list-a"><code>List ([]a)</code></a></h2>
<hr />
<p>Helios has a list type list just like the Haskell <code>List</code> type.
The type signature of the list type is <code>[]a</code> where a is the type of items in the list.
Notably, Helios list items aren't accessed using square brackets, <code>[]</code> for indexing instead the <code>get</code> method is used, check out <a href="chapter_1/../helios_builtins/Helios_Builtins.html">Helios Builtins</a>.</p>
<pre><code class="language-rust noplaypen">// A list of Integers
some_ints: []Int = []Int{1, 2, 3, 4, 5};

// Getting an element in a list
x: Int = some_ints.get(2)    // x == 3
</code></pre>
<h3 id="useful-methods"><a class="header" href="#useful-methods">Useful Methods</a></h3>
<p>Helios lists have a lot of useful methods you'd normally find in other languages</p>
<pre><code class="language-rust noplaypen">// List Methods.
fib_list: []Int = []Int{1, 1, 2, 3, 5};

//  '.len()' returns the length of the list.
fib_list.len() != 5;

//  '.get()' is used instead of square brackets for indexing an element in a list.
//! Note: Throws error if index is out of range. 
fib_list.get(4) != 5;

// Returns the element at the first element in a list.
// Note: Throws an error if list is empty.
fib_list.head() != 1;

// Returns the last element in a list
// Note: Throws an error if the list is empty.
fib_list.tail() != 5;

fib_list.prepend(0) != []Int{0, 1, 1, 2, 3, 4, 5};

[]Int{}.is_empty() == true;
</code></pre>
<h2 id="mapa-b"><a class="header" href="#mapa-b"><code>Map[a, b]</code></a></h2>
<hr />
<p>This is type is a Hashmap like <code>Map</code> in Haskell or Dictionaries in Python.
It's used to store key-value pairs.</p>
<pre><code class="language-go  noplaypen">my_map: Map[String, Int] = Map[String]Int{&quot;zero&quot;: 0, &quot;one&quot;: 1, &quot;two&quot;: 2};

print(my_map.get(&quot;zero&quot;).show()); // prints '0'
</code></pre>
<h2 id="optiona"><a class="header" href="#optiona"><code>Option[a]</code></a></h2>
<hr />
<p>The Helios <code>Option[a]</code> is a builtin <code>enum</code> used to represent an optional value of type <code>a</code>.
It's defined as:</p>
<pre><code class="language-rust  noplaypen">enum Option[a] {
    Some { some: a },
    None
}
</code></pre>
<h3 id="instantiating-an-option"><a class="header" href="#instantiating-an-option">Instantiating an <code>Option</code></a></h3>
<pre><code class="language-rust  noplaypen">some_int: Option[Int] = Option[Int]::Some{42};

none_int: Option[Int] = Option[Int]::None;
</code></pre>
<h2 id="more-information"><a class="header" href="#more-information">More Information</a></h2>
<p>For more information on the Builtin type, check out <a href="chapter_1/../helios_builtins/Helios_Builtins.html">Builtin Types</a>.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are at the core of Helios. All Helios functions are <em>pure</em>, this means they have no side effects and always return the same result when given the same arguments.</p>
<p>Functions are declared using the <code>func</code> keyword.
Helios has no <code>return</code> statement, the last expression in a function is <em>implicitly returned</em> like in Rust.</p>
<pre><code class="language-go  noplaypen">func add(a: Int, b: Int) -&gt; Int {
    a + b 
}
</code></pre>
<p>Helios has recursion as you'd expect.</p>
<pre><code class="language-go  noplaypen">func fib(n: Int) -&gt; Int {
    // Helios is expression based so the branches of an if/else loop return expressions.
    if (n &lt; 1) {
        1
    } else {
        fib(n-1) + fib(n-2)
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Functions can only reference themselves.
There is no global hoisting of <code>func</code> and other statements like in javascript.
So there is no mutual recursion using func statements directly as a function can only reference
other functions defined before it.</p>
<pre><code class="language-go  noplaypen">01 func a(n: Int) -&gt; Int {
02    ...
03     b(n)                    // This won't work
04 }
05
06 func b(n: Int) -&gt; Int {
07     ...
08     a(n)                   // This will work
09 }
</code></pre>
</blockquote>
<h2 id="lambdaanonymous-functions"><a class="header" href="#lambdaanonymous-functions">Lambda/Anonymous Functions</a></h2>
<p>Helios also has support for anonymous functions without needing the <code>func</code> keyword.
This is for convenience when using higher-order functions.
Lambdas also have some type-inference as on they don't need type annotations on
the <em>left</em> side of their declaration.</p>
<pre><code class="language-rust  noplaypen">// Lambda with full typing
is_even: (Int) -&gt; Bool = (n: Int) -&gt; Bool { (n % 2) == 0 };

// Lambda without type inference
// Note: Return type must still be specified
is_even = (n: Int) -&gt; Bool { (n % 2) == 0 };
</code></pre>
<blockquote>
<p><strong>Note:</strong> Normal Functions should be chosen when possible for better clarity.</p>
</blockquote>
<h2 id="first-class-functions"><a class="header" href="#first-class-functions">First-Class Functions</a></h2>
<p>Functions are first-class citizens in Helios this means:</p>
<h3 id="1-functions-can-be-passed-as-arguments"><a class="header" href="#1-functions-can-be-passed-as-arguments">1. Functions can be passed as arguments</a></h3>
<pre><code class="language-ts  noplaypen">evens: []Int = ([]Int{1, 2, 3, 4, 5, 6}).filter(is_even); // [2, 4. 6]; 
</code></pre>
<h3 id="2-functions-can-be-returned-from-functions"><a class="header" href="#2-functions-can-be-returned-from-functions">2. Functions can be returned from functions</a></h3>
<pre><code class="language-rust  noplaypen">add = (a: Int) -&gt; (Int) -&gt; Int { (b: Int) -&gt; Int { a + b } };
</code></pre>
<blockquote>
<p><strong>Note:</strong> Ok I <em>kind of</em> lied when I told you that Helios has first-class functions,
functions can't be stored in lists or structs so they aren't <strong>technically</strong> first-class.</p>
</blockquote>
<h2 id="example-collatz-sequence-function-"><a class="header" href="#example-collatz-sequence-function-">Example: Collatz Sequence function :)</a></h2>
<p>One of my favorite things in maths is the Collatz sequence.
A Collatz sequence starts with a random number, n
and follows <strong>three</strong> very simple rules to decide the next number in the sequence.</p>
<ul>
<li>If n is 1 the sequence is over.</li>
<li>If n is even the next number is n / 2.</li>
<li>If n is odd the next number is (n * 3) + 1.</li>
</ul>
<p>It is an open question in math whether there is a Collatz sequence that doesn't end with the number 1.
We can write a simple function to generate the Collatz sequence (as a list of <code>Int</code>s) from a given starting number.</p>
<pre><code class="language-go  noplaypen">func collatz(initial: Int, previous_numbers: []Int) -&gt; []Int {

    // Rule (1)
    if (intial == 1) {
        previous_numbers.prepend(current) 

    // Rule (2)
    } else if (initial % 2 == 0) {
        collatz(current / 2, previous_numbers.prepend(current))

    // Rule (3)
    } else {
        collatz(intial * 3 + 1, previous_numbers.prepend(intial))      
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs-and-enums"><a class="header" href="#structs-and-enums">Structs and Enums</a></h1>
<h2 id="structs"><a class="header" href="#structs">Structs</a></h2>
<p>Structs in Helios are a named grouping of types.
They are also known as <em>product types</em>.
They are similar to structs in other languages like Rust.</p>
<pre><code class="language-rust  noplaypen">// Rational (fractional type)
struct Rational {
    top: Int
    bottom: Int
}

// Instantiating a struct
x: Rational = Rational { top: 1, bottom: 3 };

// OR

// Type is inferred for struct literals
x = Rational { top: 1, bottom: 3 };
</code></pre>
<h2 id="enums"><a class="header" href="#enums">Enums</a></h2>
<p>Enums are used to represent types that have multiple variants.
Enums are also known as <code>sum types</code>.
They're useful for datums and redeemers with differing content.</p>
<pre><code class="language-rust  noplaypen">enum FanSetting {
    On{ speed: Int }
    Off
}

// Instantiating an Enum
current_setting: FanSetting = FanSetting::On { speed: 5 };

// Enums also have type inference for literals
current_setting = FanSetting::On { speed: 5 };
</code></pre>
<p><strong>Note:</strong> Enum variants with one field can be constructed without the field's name.
The example above could be rewritten as:</p>
<pre><code class="language-go  noplaypen">current_setting = FanSetting::On { 5 };
</code></pre>
<h3 id="the-switch-expression"><a class="header" href="#the-switch-expression">The <code>'switch'</code> expression</a></h3>
<p>The <code>switch</code> expression is used to pattern-match on enum variants. It's more like a C <code>switch</code> than a Rust <code>match</code>.</p>
<pre><code class="language-rust  noplaypen">enum Datum {
    Submission{...} // content of Submission has the same syntax as a regular struct-type
    Queue{...}
    Post{...}
}

example = Datum::Submission{...};

example.switch {
    // Double-colon to reference the sub-type
    x: Submission =&gt; { 
        ... // expression must use x
    },
    Datum::Queue {
        ... // x not used, so can't be declared
    },
    default { // default must come last if all sub-types of Datum aren't handled explicitely
        true
    }
}

</code></pre>
<blockquote>
<p><strong>Note:</strong> In Helios, <strong>all</strong> fields in a struct and variants in an enum <strong>must</strong> be used,
or else the compiler will throw an error.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="methods-and-associated-functions"><a class="header" href="#methods-and-associated-functions">Methods and Associated Functions</a></h1>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Structs and Enums in Helios have methods with syntax a lot like OOP languages.
Methods are declared just like regular functions but within the type declaration.</p>
<pre><code class="language-go  noplaypen">struct Rational {
    top: Int
    bottom: Int

    // Methods take an argument 'self' of the same type of the Struct
    func add(self: Rational, rhs: Rational) -&gt; Rational {
        top: Int = (self.top * rhs.bottom) + (rhs.top * self.bottom);
        bottom: Int = self.bottom * rhs.bottom;

        Rational { top: top, bottom: bottom }
    }
}
example_rational: Rational = Rational { top: 7, bottom: 21};

// Methods can be accessed using regular dot notation.
example_rational.add(example_rational)
</code></pre>
<p>Methods cannot modify the struct as all <code>Helios</code> values are immutable.</p>
<p>Methods are just syntactic sugar.
They are desugared to a <strong>curried function</strong> (a function that returns a function) that takes the <code>self</code> type as it's first argument:</p>
<pre><code class="language-rust  noplaypen">// This:
rational_1.add(rational_2); 
// Becomes __user__Rational_add(rational_1)(rational_2)
// of type (Rational) -&gt; (Rational) -&gt; Rational


// 'rational.add' returns a function of type ((Rational) -&gt; Rational) 
// the first '(Rational) -&gt;' in 'add' is set to rational_1
// that can be used immediately or stored like any other value.
add_to_rational_1: (Rational) -&gt; Rational = rational_1.add;

// Note: add_to_rational_1(rational_2) == rational_1.add(rational_2)
</code></pre>
<h2 id="associated-functions-and-constants"><a class="header" href="#associated-functions-and-constants">Associated Functions and Constants</a></h2>
<p>Associated functions and constants are just like regular constants or functions but they are namespaced by a Type.
E.g Car::new(a, b, c).
Associated functions are just like <em>static methods</em> in most OOP languages.</p>
<h3 id="defining-associated-functions"><a class="header" href="#defining-associated-functions">Defining Associated Functions</a></h3>
<p>Associated functions are defined just like methods but without the <code>self</code> argument.</p>
<pre><pre class="playground"><code class="language-rust  playpen">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const Rational::PI = Rational{355, 113}

func Rational::new(top: Int, bottom: Int) -&gt; Rational {
    Rational { top: top, bottom: bottom }
}
<span class="boring">}
</span></code></pre></pre>
<h3 id="using-associated-functions-and-constants"><a class="header" href="#using-associated-functions-and-constants">Using Associated Functions and Constants</a></h3>
<p>Associated Functions and Constants are <em>namespaced</em> by the type they are associated with
and can be accessed using two colons (<code>::</code>) just like in Rust.
For example:</p>
<pre><code class="language-rust  noplaypen">// Using Associated functions
fifty_fifty: Rational = Rational::new(1, 2)
</code></pre>
<h2 id="finished-code"><a class="header" href="#finished-code">Finished Code</a></h2>
<pre><code class="language-ts">struct Rational {
    top: Int
    bottom: Int

    const Rational::PI = Rational{ top: 355, bottom: 113}

    func new(top: Int, bottom: Int) -&gt; Rational {
        Rational { top: top, bottom: bottom }
    }

    func add(self: Rational, rhs: Rational) -&gt; Rational {
        top: Int = (self.top * rhs.bottom) + (rhs.top * self.bottom);
        bottom: Int = self.bottom * rhs.bottom;

        Rational { top: top, bottom: bottom }
    }

}

rational_1: Rational = Rational::new(1, 5); // 1/5 or 0.2
rational_2: Rational = Rational::new(2, 5); // 2/5 or 0.4

res: Rational = rational_1.add(rational_2); // 3/5 or 0.6

// Using Associated functions
fifty_fifty: Rational = Rational::new(1, 2); // 1/2 or 0.5

</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="comments-and-printing"><a class="header" href="#comments-and-printing">Comments and Printing</a></h1>
<h2 id="comments"><a class="header" href="#comments">Comments</a></h2>
<p>In Helios single-line comments are declared using two forward slashes (<code>//</code>).</p>
<pre><code class="language-rust  noplaypen">// This is a comment.
</code></pre>
<p>Multi-line comments are declared using <code>/* ... */</code>.</p>
<pre><code class="language-rust  noplaypen">/*
    This is a multi-line comment.
*/
</code></pre>
<h2 id="printing"><a class="header" href="#printing">Printing</a></h2>
<p>For debugging purposes, Helios has a <code>print</code> function.
<code>print(...)</code> must be followed by a semicolon and another expression.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print(&quot;Imagine something cool.&quot;);
...
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: Printing can be useful when debugging scripts, but should be avoided in production code as it increases the on-chain script size unnecessarily.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-printing-and-traces"><a class="header" href="#control-flow-printing-and-traces">Control Flow, Printing and Traces</a></h1>
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<p>Helios supports <code>if/else</code> statements.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if (true) {
    23
} else {
    42
}
<span class="boring">}
</span></code></pre></pre>
<p>In Helios <code>if</code>/<code>else</code> statements are expressions.
So the last expression is implicitly returned much like Rust and Ruby.
This is valid syntax:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x: Int = if (true) {
            42
        } else {
            24
        };
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: Compile-time constants can only be set to the result of an <code>if</code>/<code>else</code> expression
that results in a constant value.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-programming-in-helios"><a class="header" href="#blockchain-programming-in-helios">Blockchain Programming in Helios</a></h1>
<p>Helios is a DSL(Domain Specific Language) made for <strong>blockchain development</strong> on the Cardano blockchain.
In the following chapters we will learn how to use Helios to write smart contracts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="understanding-the-eutxo-model"><a class="header" href="#understanding-the-eutxo-model">Understanding The eUTXO Model</a></h1>
<p>Before we get into any coding we need to first understand how smart contracts work on Cardano
and how it differs from the currently more popular Accounts-based model.</p>
<p>This section wouldn't be possible without <a href="https://dav009.medium.com/learning-ergo-101-blockchain-paradigm-eutxo-c90b0274cf5e">this</a> great blog post by the awesome <a href="https://github.com/dav009">David Pryzbilla</a> and a lot of helpful feedback from <a href="https://github.com/christianschmitz">Christian Schmitz</a>.</p>
<h2 id="accounts-model-vs-eutxo-model"><a class="header" href="#accounts-model-vs-eutxo-model">Accounts Model vs eUTXO Model</a></h2>
<p>Smart contracts on Cardano are quite different from those on Ethereum.</p>
<h3 id="ethereum-style-smart-contracts-accounts-based-model"><a class="header" href="#ethereum-style-smart-contracts-accounts-based-model">Ethereum-style Smart Contracts (Accounts-based Model)</a></h3>
<p>When a transaction occurs, the balance of one the sender's account is directly decremented and that of the recipient is incremented, like with a bank account.</p>
<p>Contracts on Ethereum run via the EVM(Ethereum Virtual Machine),
the EVM can be thought of as a sort global onchain computer that smart contracts take turns to run on before being accepted onchain.</p>
<blockquote>
<p><strong>Note</strong>: The data of all accounts on Ethereum are stored in a <a href="https://ethereum.org/en/developers/docs/data-structures-and-encoding/patricia-merkle-trie/"><strong>Merkle-Patricia Trie</strong></a>, which is kind of like a fancy hashmap.
After all the transaction in a block are run the <strong>root hash</strong> of the new Trie is included in the block.</p>
</blockquote>
<h2 id="the-eutxo-model"><a class="header" href="#the-eutxo-model">The eUTXO Model</a></h2>
<p>In the UTXO model tokens are stored in UTXOs (Unspent Transaction Outputs).
A UTXO is like (electronic)-cash where an individual bundle of bills (Ada and native-tokens) is stored separately.</p>
<p>In a transaction in the UTXO model, one or more UTXOs are used as inputs to the transaction and destroyed, <strong>Transaction Inputs</strong> and one or more UTXOs are created as the result/output of a transaction, <strong>Transaction Outputs</strong>.</p>
<p>Transactions in the accounts-based model mutate the data-points storing the total amounts (this is <strong><em>very, very</em> dangerous</strong> regular banks have special insurances and paper backups in case of mistakes, blockchains have no such systems).
In the UTXO model only the &quot;bills&quot; that participate in a given transaction can potentially be lost (bad, but nothing catastrophic).</p>
<p>A UTXO chain can emulate account-based models (for example the <a href="https://fuel.network">Fuel Rollup</a> uses UTXOs under the hood for parallel execution) and vice versa.</p>
<h3 id="components-of-a-utxo-on-cardano"><a class="header" href="#components-of-a-utxo-on-cardano">Components of a UTXO on Cardano</a></h3>
<p>On eUTXO blockchain the ledger is made up of many UTXOs(Unspent Transcation Outputs). A UTXO has four main components:</p>
<ul>
<li>An Address</li>
<li>Tokens (Native Assets)</li>
<li>A Validator Script</li>
<li>A Datum.</li>
</ul>
<h4 id="the-address"><a class="header" href="#the-address">The Address</a></h4>
<p>The address of a UTXO is used to determine who owns the UTXO (who has the right to spend it in a transaction).
To know the balance of a user wallets searches the ledger for all UTXOs <em>owned</em> by the user's address and their total value is the user's balance.</p>
<p>An address can be either be derived from the hash of a user's public key (<code>PubKeyHash</code> in Helios) or the hash of a validator script (<code>ValidatorHash</code>).</p>
<h4 id="datums"><a class="header" href="#datums">Datums</a></h4>
<p>These are data stored onchain associated with a particular UTXO.
The Datum is used to store state in Smart Contracts.
The 'e' in eUTXO comes from the Datum, this is because the addition of a datum makes the eUTXO model Turing-Complete (like Ethereum smart contracts and unlike Bitcoin Script).
With this state anything that an account-based model can do also be done with a eUTXO-based model.@hyperionbt/helios&quot;</p>
<blockquote>
<p><strong>Note</strong>: To be exact on Cardano previously the Datum couldn't be stored onchain but as of Plutus V2 we now have actual <em>onchain/inline</em> datums.</p>
</blockquote>
<h4 id="validators"><a class="header" href="#validators">Validators</a></h4>
<p>A validators is a function that runs when a transaction attempts to spend a UTXO.
It takes in the data of the transaction and returns a boolean which determines if the UTXO can be spent.
Validators contain the 'business logic' of a smart contract.</p>
<p>For example for a simple vesting contract one could lock up some tokens in a UTXO with a validator which returns <code>true</code> if the transaction is signed by the beneficiary.</p>
<blockquote>
<p><strong>Note</strong>: A UTXO can only be spent once. In every transaction some UTXOs are destroyed,
<strong>Transaction Inputs (TxInputs)</strong> and new UTXOs are created, <strong>Transaction Inputs (TxOutputs)</strong>.
For a transaction to be valid it must satisfy some things:</p>
<ul>
<li>The total amount of tokens in the <strong>Transaction Inputs</strong> must be equal to those in the <strong>Transaction Ouputs</strong>.</li>
<li>The validators for all the <strong>Transaction Inputs</strong> must evaluate to <code>true</code>.</li>
</ul>
</blockquote>
<h2 id="pros-and-cons-of-the-eutxo-model"><a class="header" href="#pros-and-cons-of-the-eutxo-model">Pros and Cons of the eUTXO Model</a></h2>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<ul>
<li>
<h4 id="fixed-transaction-fees"><a class="header" href="#fixed-transaction-fees">Fixed Transaction Fees</a></h4>
<p>eUTXO contracts are deterministic this means that you can verify if a transaction will suceed and it's resource usage before posting it to the blockchain.
This is means the transaction fees for a transaction are fixed  and can be deterministically calculated offchain.
On Account-based blockchains transaction fees can vary <strong>a lot</strong>.</p>
</li>
<li>
<h4 id="easier-to-audit"><a class="header" href="#easier-to-audit">Easier to Audit</a></h4>
<p>The <strong>locally-scoped</strong> nature of eUTXO contracts reduces the potential attack surface by a lot.
This makes auditing way easier because you're auditing a <strong>the validation</strong> function and the space of possible outcomes is greatly reduced.</p>
</li>
<li>
<h4 id="concurrency"><a class="header" href="#concurrency">Concurrency</a></h4>
<p>If designed properly eUTXO smart contracts can be very parallel.</p>
</li>
<li>
<h4 id="better-for-layer-2s"><a class="header" href="#better-for-layer-2s">Better for Layer 2s</a></h4>
<p>The local nature of UTXOs lends itself well to building Layer 2 scaling solutions
such as sidechains(Milkomeda), state channels</p>
</li>
<li>
<h4 id="simpler"><a class="header" href="#simpler">Simpler</a></h4>
<p>Though not immediately obvious eUTXO smart contracts are often simpler than an equivalent Solidity smart contract.</p>
</li>
<li>
<h4 id="no-reentrancy-attacks"><a class="header" href="#no-reentrancy-attacks">No Reentrancy Attacks</a></h4>
<p>Reentrancy attacks such as the <a href="https://en.wikipedia.org/wiki/The_DAO_(organization)">DAO hack</a>.</p>
</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<ul>
<li>
<h4 id="contention"><a class="header" href="#contention">Contention</a></h4>
<p>If eUTXO contracts aren't designed properly they can encounter <em>contention</em>.
Contention occurs when two transaction try to spend the same UTXO,
this isn't possible and leads to UX issues like in the case of <a href="chapter_2/">Minswap in the past</a>.
This is not usually an issue on Ethereum as the EVM usually handles ordering smart contract calls.</p>
<blockquote>
<p><strong>Note</strong>: There are ways to take advantage of the avoid contention and take advantage of
the parallel nature of UTXOs instead of struggling with the such as SundaeSwap's <a href="chapter_2/">scooper model</a>.</p>
<p>These approaches usually use <em>offchain batching</em> to execute 'batches' of UTXOs in a single efficient transaction.
This can be done trustlessy as a UTXO can't be spent in a transaction unless it's validator is satisfied.</p>
</blockquote>
</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>It's totally normal if you're still confused about eUTXO it's not immediately intuitive.
It is worth the extra effort in rewiring you're thinking as it often leads to contracts that are simpler and safer overall.</p>
<p>I advise you to read <a href="https://dav009.medium.com/learning-ergo-101-blockchain-paradigm-eutxo-c90b0274cf5e">this article</a> top even if you understand eUTXO, it's written for the Ergo blockchain but a lot of the concepts carry over into cardano.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validator-scripts"><a class="header" href="#validator-scripts">Validator Scripts</a></h1>
<p>In the last chapter we learnt that validators are functions that return a boolean (<code>true</code>  or <code>false</code>) when validating a transaction. In Helios validators are functions that take three arguments:</p>
<ul>
<li>The Redeemer: A piece of data attached to the transaction.</li>
<li>The Datum: Data stored onchain linked to the UTXO.</li>
<li>The ScriptContext: This is huge struct that holds data about the transaction spending the UTXO.</li>
</ul>
<p>The Redeemer and the Datum are user-defined but the <code>ScriptContext</code> struct is the same across all validators.</p>
<p>A simple validator</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spending always_true;       // -------- (1)

struct Datum {..}           // --------- (2)

enum Redeemer {..}          // --------- (3)
                            
// ------------- (4)
func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -&gt; Bool {
    ...
    true                     
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="script-purpose"><a class="header" href="#script-purpose">Script Purpose</a></h2>
<p>In Helios all scripts start with a  <strong>script purpose</strong>(1), followed by the name of the script. There are three (3) script purposes currently:</p>
<ul>
<li><strong>spending</strong></li>
<li><strong>minting</strong></li>
<li><strong>testing</strong></li>
</ul>
<p>We will cover the latter two in later chapters.</p>
<pre><code class="language-rust  noplaypen">spending always_true
</code></pre>
<h2 id="the-main-function"><a class="header" href="#the-main-function">The Main Function</a></h2>
<p>The main function of a validator accepts three arguments and returns a <code>Bool</code>:</p>
<ul>
<li><strong>The Datum</strong> (2)</li>
<li><strong>The Redeemer</strong> (3)</li>
<li><strong>The ScriptContext</strong></li>
</ul>
<pre><code class="language-go  noplaypen">spending always_true

struct Datum {..}

struct Redeemer {..}

func main(datum: Datum, redeemer: Redeemer, context: ScriptContext) -&gt; Bool {
    ...
    true
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: The Datum and the Redeemer are user-defined types (structs or enums) that <strong>must</strong> be named <code>Datum</code> and <code>Redeemer</code>.</p>
</blockquote>
<h2 id="alwaystrue-validator"><a class="header" href="#alwaystrue-validator">AlwaysTrue Validator</a></h2>
<pre><code class="language-go  noplaypen">spending always_true

struct Datum {..}

struct Redeemer {..}

func main(datum: Datum, redeemer: Redeemer, context: ScriptContext) -&gt; Bool {
    ...
    true
}
</code></pre>
<h2 id="omitting-validator-arguments"><a class="header" href="#omitting-validator-arguments">Omitting Validator Arguments</a></h2>
<p>The above validator could be rewritten as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>spending always_true     

func main(ctx: ScriptContext) -&gt; Bool {        // -------- (2)
    ...
    true                     
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: The Helios compiler is smart enough to fill in a blank redeemer and datum when they are omitted.</p>
</blockquote>
<p>Most of the data needed for writing useful validators is contained in the <code>ScriptContext</code>.
We will cover the <code>ScriptContext</code> in the next page.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-scriptcontext"><a class="header" href="#the-scriptcontext">The ScriptContext</a></h1>
<p>The <code>ScriptContext</code> contains all the data about the transaction and is usually the most important argument in determining whether a <code>validator</code> should succeed or fail.
Because of how important it is we are going to try to go fairly deep into the internals in this chapter.</p>
<p>This is roughly the internal implementation of the <code>ScriptContext</code> struct.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ScriptContext {
    tx: Tx

    // Some useful methods

    // Serializes the ScriptContext to a ByteArray.
    func serialize(self) -&gt; ByteArray;

    // Get the hash of the Validator being evaluated.
    func get_current_validator_hash(self) -&gt; ByteArray;

    // Get the TxInput locked by the validator.
    func get_current_input(self) -&gt; TxInput;

    // Get the ValidatorHash of the current Validator
    func get_current_validator_hash(self) -&gt; ByteArray;
}
<span class="boring">}
</span></code></pre></pre>
<blockquote>
<p><strong>Note</strong>: Internally <code>ScriptContext</code> is a wrapper around the <code>Tx</code> struct,
the <code>Tx</code> holds the metadata of a signed onchain transaction.</p>
</blockquote>
<h2 id="tx"><a class="header" href="#tx">Tx</a></h2>
<p>The <code>Tx</code> struct stores the data on the current transaction.</p>
<pre><code class="language-rust  noplaypen">struct Tx {
    id: TxId
    inputs: []TxInput          // Transaction inputs
    outputs: []TxOutput        // Transaction outputs
    fee: Value                 // Fee paid for this transaction
    minted: Value              // Value minted by this transaction
    time_range: TimeRange      // Valid range for this transaction
    signatories: []PubKeyHash  // Signatories of the transaction

    // Some useful methods

    func serialize(self) -&gt; ByteArray;

    func now(self) -&gt; Time;

    func outputs_sent_to(self, addr: PubKeyHash) -&gt; []TxOutput;

    func value_sent_to(self, addr: PubKeyHash) -&gt; Value;

    func value_locked_by(self, val_hash: ValidatorHash) -&gt; Value

    func value_locked_by_datum(self, )

    // Checks if a given PubKey
    func is_signed_by(self, pk: PubKeyHash) -&gt; Bool;

}

</code></pre>
<h2 id="txinput"><a class="header" href="#txinput">TxInput</a></h2>
<p>The <code>TxInput</code> struct as you've probably guessed represents a <strong>Transaction Input</strong>.
As you can see a <strong>Transaction Input</strong> is just a wrapper around UTXO created by a previous transaction on the blockchain.</p>
<pre><code class="language-rust  noplaypen">struct txInput {
    output_id: Int        // ID of the UTXO
    output: TxOutput      // UTXO being use
}
</code></pre>
<h2 id="txoutput"><a class="header" href="#txoutput">TxOutput</a></h2>
<p>The <code>TxOutput</code> represents a <strong>Transaction Output</strong> this is a <strong>UTXO(Unspent Transaction Output)</strong> that will be created by this transaction.</p>
<pre><code class="language-rust  noplaypen">struct TxOutput {
    address: Address             // Address of the UTXO
    value: Value                 // Value in the UTXO
    datum_hash:  ByteArray       // Hash of the UTXO's datum
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: For more info on the <code>Address</code> and <code>Value</code> types check out <a href="chapter_2/../helios_builtins/Helios_Builtins.html">Helios Builtins</a> 🙂.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="vesting-contract"><a class="header" href="#vesting-contract">Vesting Contract</a></h1>
<p>To put what we've done so far to use we're going to build a simple 'vesting' contract.
This contract will lock up some tokens owned by an <strong>owner</strong>
for a <strong>beneficiary</strong> that can't be claimed until after a <strong>deadline</strong>.
The <strong>owner</strong> can get their funds back if the <strong>deadline</strong> has not passed yet</p>
<h2 id="the-datum"><a class="header" href="#the-datum">The Datum</a></h2>
<p>The Datum stores the <code>PubKeyHash</code> of the <strong>beneficiary</strong> and <strong>creator</strong>'s wallets and the vesting deadline is represented as a <code>Time</code>.</p>
<pre><code class="language-rust  noplaypen">struct Datum {
    creator: PubKeyHash
    beneficiary: PubKeyHash
    deadline: Time
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: The <code>Time</code> type represents a POSIX time and
for more info <a href="chapter_2/../helios_builtins/Helios_Builtins.html">Helios Builtins</a>.</p>
</blockquote>
<h2 id="the-redeemer"><a class="header" href="#the-redeemer">The Redeemer</a></h2>
<pre><code class="language-rust  noplaypen">enum Redeemer {
    Cancel
    Claim
}
</code></pre>
<p>There are two cases when the validator should return <code>true</code>:</p>
<ul>
<li>
<p><strong>Cancel</strong></p>
<p>In this case, the 'owner' wishes to cancel the contract and get back their funds.
For a 'Cancel' to succeed the following have to be checked</p>
<ul>
<li>The owner signed the transaction.</li>
<li>The deadline hasn't passed.</li>
</ul>
</li>
<li>
<p><strong>Vesting Claim</strong></p>
<p>A 'Claim' occurs when the 'beneficiary' wishes to claim the tokens vested for them.
For it to be valid the following have to be checked:</p>
<ul>
<li>The beneficiary signed the transaction.</li>
<li>The deadline has passed.</li>
</ul>
</li>
</ul>
<h2 id="the-main-function-1"><a class="header" href="#the-main-function-1">The Main Function</a></h2>
<pre><code class="language-go  noplaypen">func main(datum: Datum, redeemer: Redeemer, context: ScriptContext) -&gt; Bool {
    tx: Tx = context.tx;
    now: TimeRange = tx.now();

    redeemer.switch {
        Cancel =&gt; {
            // Check that deadline hasn't passed
            now &lt; datum.deadline &amp;&amp; 

            // Check that the owner signed the transaction
            tx.is_signed_by(datum.creator)
        },
        Claim =&gt; {
           // Check that deadline has passed.
           now &gt; datum.deadline &amp;&amp;

           // Check that the beneficiary signed the transaction.
           tx.is_signed_by(datum.beneficiary)
        }
    }
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: A <code>TimeRange</code> represents a <em>range</em> of time using a pair of <code>Time</code> values.
for more info <a href="chapter_2/../helios_builtins/Helios_Builtins.html">Helios Builtins</a>.</p>
</blockquote>
<blockquote>
<p><strong>P.S.</strong>: There is a <em>possible</em> security vulnerability in this contract that we will examine in a later chapter.
See if  you can find it 🙂.</p>
</blockquote>
<h2 id="finished-code-1"><a class="header" href="#finished-code-1">Finished Code</a></h2>
<pre><code class="language-go  noplaypen">spending vesting;

struct Datum {
    creator: PubKeyHash
    beneficiary: PubKeyHash
    deadline: Time
}

enum Redeemer {
    Cancel
    Claim
}

func main(datum: Datum, redeemer: Redeemer, context: ScriptContext) -&gt; Bool {
    tx: Tx = context.tx;
    now: Time = tx.now();

    redeemer.switch {
        Cancel =&gt; {
            now &gt; datum.deadline &amp;&amp;
            tx.is_signed_by(datum.creator)
        },
        Claim =&gt; {
           now &gt; datum.deadline &amp;&amp;
           tx.is_signed_by(datum.beneficiary)
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="english-auction"><a class="header" href="#english-auction">English Auction</a></h1>
<p>In this example, we will rewrite the <a href="https://plutus-pioneer-program.readthedocs.io/en/latest/pioneer/week1.html">English Auction contract</a>
from the Plutus Pioneer's program in Helios.</p>
<p>This validator is can be used to lock assets that are to be auctioned in a UTXO.</p>
<h2 id="the-datum-1"><a class="header" href="#the-datum-1">The Datum</a></h2>
<pre><code class="language-go">spending english_auction

struct Datum {
    seller: PubKeyHash
    bid_asset: AssetClass       // allow alternative assets (not just lovelace)
    min_bid: Int
    deadline: Time
    for_sale: Value             // the asset that is being auctioned
    highest_bid: Int            // initialized at 0, which signifies the auction doesn't yet have valid bids
    highest_bidder: PubKeyHash

    func update(self, highest_bid: Int, highest_bidder: PubKeyHash) -&gt; Datum {
        Datum {
            seller: self.seller,
            bid_asset: self.bid_asset,
            min_bid: self.min_bid,
            deadline: self.deadline,
            for_sale: self.for_sale,
            highest_bid: highest_bid,
            highest_bidder: highest_bidder
        }
    }
}

enum Redeemer {
    Close 
    Bid { bidder: PubKeyHash, bid: Int }
}

func main(datum: Datum, redeemer: Redeemer, ctx: ScriptContext) -&gt; Bool {
    tx: Tx = ctx.tx;

    now: Time = tx.now();

    validator_hash: ValidatorHash = ctx.current_validator_hash();

    redeemer.switch {
        Close =&gt; {
            if (datum.highest_bid &lt; datum.min_bid) {
                // the forSale asset must return to the seller, what happens to any erroneous bid value is irrelevant
                tx
                  .value_sent_to(datum.seller)
                  .contains(datum.for_sale + datum.highest_bid) &amp;&amp;
                // Check that the deadline has passed
                now &gt; datum.deadline                                    
            } else {
                // Check that the seller receives the highest bid
                tx
                  .value_sent_to(datum.seller)
                  .contains(Value::new(datum.bid_asset, datum.highest_bid))    &amp;&amp;
                // Check that highest bidder is given the token being auctioned
                tx
                  .value_sent_to(datum.highest_bidder)
                  .contains(datum.for_sale)                                    &amp;&amp;
                // Check that the deadline has passed
                now &gt; datum.deadline                                    
            }
        },
        b: Bid =&gt; {
            if (b.bid &lt; datum.min_bid) {
                false
            } else if (b.bid &lt;= datum.highest_bid) {
                false
            } else {
                // first bid is placed by the auction creator
                expected_datum: Datum = datum.update(b.bid, b.bidder);

                // Check that new Auction UTXO contains the token for sale and the new bid
                tx
                  .value_locked_by_datum(validator_hash, expected_datum)
                  .contains(datum.for_sale + Value::new(datum.bid_asset, b.bid)) &amp;&amp;
                // Check that the old highest bidder is repayed
                tx
                  .value_sent_to(datum.highest_bidder)
                  .contains(Value::new(datum.bid_asset, datum.highest_bid))      &amp;&amp;
                // Check that the deadline hasn't passed
                now &lt; datum.deadline
            }
        }
    }
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-assets"><a class="header" href="#native-assets">Native Assets</a></h1>
<p>One of Cardano's best features is <strong>Native Multi-Asset(NMA)</strong>.
It's a bit of a mouthful but what this means is that on Cardano
user-defined tokens have the same treatment as the native coin (ADA).</p>
<p>This might not seem like a big deal but this offers serious advantages
over Ethereum tokens (ERC-20 and ERC-721). But to understand the benefits
you have to understand how user-defined tokens work on non-UTXO blockchains.</p>
<h2 id="erc-20-standard"><a class="header" href="#erc-20-standard">ERC-20 Standard</a></h2>
<p>On Ethereum, tokens are defined using the <a href="https://ethereum.org/en/developers/docs/standards/tokens/erc-20/">ERC-20 standard</a>.
In this standard tokens are managed by a contract that stores all of the token's metadata
and all user balances in a <code>mapping</code> (hashmap) called <code>_balances</code>.
All transfers of an ERC-20 token are function calls to the contract to modify the <code>_balances</code>.</p>
<p>Any error in the implementation of the ERC-20 standard can lead to the loss of user funds.</p>
<h2 id="utxo-native-assets"><a class="header" href="#utxo-native-assets">UTXO Native Assets</a></h2>
<p>On Cardano and other eUTXO blockchains user-defined tokens are <em>first-class</em>.
Tokens on Cardano are stored in <strong>Token Bundles</strong> which can contain
ADA and any native asset.
This allows Cardano to do in one transaction what would normally take multiple
contract calls on Ethereum.</p>
<blockquote>
<p><strong>Note</strong>: A <strong>Token Bundle</strong> must contain a minimum amount of ADA
at the time of this writing this is 1 ADA.</p>
</blockquote>
<h3 id="minting-policies"><a class="header" href="#minting-policies">Minting Policies</a></h3>
<p>Minting policies are a lot like validator scripts, they run when a transaction
attempts to mint a token and return a boolean that determines whether the minting is valid.</p>
<p>There are a few key differences:</p>
<ul>
<li>Minting policies are not directly linked to any UTXO
they are included in the minting transaction directly.</li>
<li>Minting policies take two arguments (the <code>ScriptContext</code> and the <code>Redeemer</code>)
they have no UTXO and therefore no Datum and don't need
a Redeemer.</li>
</ul>
<h3 id="assetclass"><a class="header" href="#assetclass">AssetClass</a></h3>
<p>Native assets are identified by their <code>AssetClass</code> this is a combination of:</p>
<ul>
<li>
<p><strong>It's <code>MintingPolicyHash</code></strong>
This is simply the hash of the minting policy of the token.
It is sometimes called the CurrencySymbol or Policy ID.</p>
</li>
<li>
<p><strong>It's <code>TokenName</code></strong>
This is an (immutable) property of an asset that is used to distinguish different assets within the same policy.</p>
</li>
</ul>
<pre><code class="language-rust  noplaypen">struct AssetClass {
    ...

    // ADA's assetclass
    const ADA: AssetClass

    // Constructor
    func new(policy_hash: ByteArray, token_name: String) -&gt; AssetClass;
}
</code></pre>
<blockquote>
<p><strong>Note:</strong> The MintingPolicyHash of ADA is an empty string (<code>&quot;&quot;</code>) since nothing can hash
to an empty string ADA is the only token that can't be minted using a minting policy.</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="value"><a class="header" href="#value">Value</a></h1>
<p>The <code>Value</code> type represents a <em>token bundle</em> using pairs of asset classes (<code>AssetClass</code>)  and amounts (<code>Int</code>).</p>
<pre><code class="language-go  noplaypen">// The Value type is opaque (it's internals are abstracted away for developers)
struct Value {
    ...

    // A constant representing an empty Value.
    const ZERO: Value

    // Instantiates a Value of a given AssetClass and Amount.
    func new(asset_class: AssetClass, amount: Int) -&gt; Value;

    // Constructs a Value containing 'amount' number of lovelaces.
    func lovelace(amount: Int) -&gt; Value;

    // Checks if a Value is empty.
    func is_zero(self) -&gt; Bool;

    // Gets the amount of a specific AssetClass contained in a Value.
    func get(self, asset_class: AssetClass) -&gt; Int;

    // Returns 'true' if self contains other_value.
    func contains(self, other_value: Value) -&gt; Bool;
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: 1 ADA is equal to 1,000,000,000 Lovelace</p>
</blockquote>
<div style="break-before: page; page-break-before: always;"></div><h1 id="signed-policy"><a class="header" href="#signed-policy">Signed Policy</a></h1>
<p>This example will be a simple minting policy that allows minting as long as
the transaction is signed by an <strong>owner</strong> which will just be a <strong>PubKeyHash</strong>.</p>
<pre><code class="language-go  noplaypen">minting signed

const OWNER: PubKeyHash = #26372...

func main(context: ScriptContext) -&gt; Bool {
    context.tx.is_signed_by(OWNER)
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="simple-nft"><a class="header" href="#simple-nft">Simple NFT</a></h1>
<p>NFTs (Non-Fungible tokens) are simply tokens with a quantity of 1.
To make an NFT the minting policy must make sure that it can only be used once and that only one token can ever be minted.
The <strong>Token Name</strong> for the NFT in this example will be called <code>example_nft</code>.</p>
<p>There are two ways to do this on Cardano:</p>
<ul>
<li>Deadline-based Approach</li>
<li>UTXO-based Approach</li>
</ul>
<h2 id="deadline-based-approach"><a class="header" href="#deadline-based-approach">Deadline-based Approach</a></h2>
<p>NFTs were available on Cardano before smart contracts (Mary Hardfork) and they were implemented using deadlines.
The main idea is that the token can only be minted before a deadline which already passed.
This ensures no new tokens will ever be minted.
This is very easy to implement:</p>
<pre><code class="language-go  noplaypen">minting deadline_nft

const DEADLINE: Time = Time::new(1212)


func main(context: ScriptContext) -&gt; Bool {
    nft_assetclass: AssetClass = 
        AssetClass::new(context.get_current_minting_policy, &quot;example-nft&quot;);
    value_minted: Value = context.minted;

    value_minted == Value::new(nft_assetclass, 1) &amp;&amp; 
    context.now() &lt; DEADLINE
}
</code></pre>
<blockquote>
<p><strong>Note</strong>: Nearly all types in Helios have a <code>serialize</code> method which can be used to convert them to a <code>ByteArray</code>.</p>
</blockquote>
<h2 id="utxo-based-approach"><a class="header" href="#utxo-based-approach">UTXO-Based Approach</a></h2>
<p>This method is based on an <a href="https://plutus-pioneer-program.readthedocs.io/en/latest/pioneer/week5.html">example</a> in the Plutus Pioneer Program.
This approach takes advantage of the fact that all UTXOs have a unique <code>TxOutputId</code>.
A UTXO's <code>TxOutputId</code> is made up of the transaction hash of the transaction that made the UTXO and the index of the UTXO in the outputs of that transaction.
It's a builtin type that is defined as:</p>
<pre><code class="language-go  noplaypen">struct TxOutputId {
    tx_id: TxId
    index: Int
}
</code></pre>
<p>So with this approach, we specify in the minting policy that the transaction minting the NFT must spend a UTXO with a specific <strong>Output ID</strong>.
Since a UTXO can only be spent once this means the token can only be minted once.</p>
<pre><code class="language-go  noplaypen">minting utxo_nft

const OUTPUT_ID: TxOutputId = TxOutputId::new(TxId::new(#1213), 1)

func main(context: ScriptContext) -&gt; Bool {
    nft_assetclass: AssetClass = 
        AssetClass::new(context.get_current_minting_policy(), &quot;example-nft&quot;);
    value_minted: Value = context.minted;

    value_minted == Value::new(nft_assetclass, 1) &amp;&amp; 
    context.inputs
        .any((input: TxInput) -&gt; Bool {input.output_id == OUTPUT_ID})

}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="helios-builtins"><a class="header" href="#helios-builtins">Helios Builtins</a></h1>
<p>This book is also meant to be a guide to the internals of Helios for Helios developers and other compiler implementations of Helios in the future.</p>
<h2 id="sections"><a class="header" href="#sections">Sections</a></h2>
<ul>
<li><a href="helios_builtins/./primitive_types.html">Primitive Types</a></li>
<li><a href="helios_builtins/./time_types.html">Time Types</a></li>
<li><a href="helios_builtins/./cryptography_types.html">Cryptography Types</a></li>
<li><a href="helios_builtins/./native-asset_types.html">Native-Asset Types</a></li>
<li><a href="helios_builtins/./transaction_types.html">Transaction Types</a></li>
</ul>
<h2 id="helios-operators"><a class="header" href="#helios-operators">Helios Operators</a></h2>
<table><thead><tr><th style="text-align: left">Operator</th><th style="text-align: left">Internal Name</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>==</code></td><td style="text-align: left"><code>__eq</code></td></tr>
<tr><td style="text-align: left"><code>!=</code></td><td style="text-align: left"><code>__neq</code></td></tr>
<tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left"><code>__gt</code></td></tr>
<tr><td style="text-align: left"><code>&gt;=</code></td><td style="text-align: left"><code>__geq</code></td></tr>
<tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left"><code>__lt</code></td></tr>
<tr><td style="text-align: left"><code>&lt;=</code></td><td style="text-align: left"><code>__leq</code></td></tr>
<tr><td style="text-align: left"><code>!</code></td><td style="text-align: left"><code>__not</code></td></tr>
<tr><td style="text-align: left"><code>and</code></td><td style="text-align: left"><code>__and</code></td></tr>
<tr><td style="text-align: left"><code>or</code></td><td style="text-align: left"><code>__or</code></td></tr>
</tbody></table>
<div style="break-before: page; page-break-before: always;"></div><h1 id="primitive-types-1"><a class="header" href="#primitive-types-1">Primitive Types</a></h1>
<p>Helios has six (6) primitive types.</p>
<h2 id="int-1"><a class="header" href="#int-1">Int</a></h2>
<hr />
<p>This is an unbounded integer like Haskell's <code>Integer</code> type.</p>
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code></p>
<h3 id="methods-1"><a class="header" href="#methods-1">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: Int) -&gt; ByteArray;

func to_bool(self: Int) -&gt; Bool;

func show(self: Int) -&gt; String;
</code></pre>
<h3 id="internal-namespace"><a class="header" href="#internal-namespace">Internal Namespace</a></h3>
<p><code>__helios__int</code></p>
<h2 id="bool-1"><a class="header" href="#bool-1">Bool</a></h2>
<hr />
<p>Represents a boolean value (<code>true</code>/<code>false</code>).</p>
<pre><code class="language-go  noplaypen">true_val: Bool = true;
false_val: Bool = false;
</code></pre>
<h3 id="associated-functions"><a class="header" href="#associated-functions">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func and(bool_1: Bool, bool_2: Bool) -&gt; Bool

func or(bool_1: Bool, bool_2: Bool) -&gt; Bool
</code></pre>
<h3 id="operators-1"><a class="header" href="#operators-1">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>not</code>, <code>and</code>, <code>or</code></p>
<h3 id="methods-2"><a class="header" href="#methods-2">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: Bool) -&gt; ByteArray;

func to_int(self: Bool) -&gt; Int;

func show(self: Bool) -&gt; String;
</code></pre>
<h3 id="internal-namespace-1"><a class="header" href="#internal-namespace-1">Internal Namespace</a></h3>
<p><code>__helios__bool</code></p>
<h2 id="string-1"><a class="header" href="#string-1">String</a></h2>
<hr />
<p>This is a fixed-size string.</p>
<pre><code class="language-rust  noplaypen">example: String = &quot;Woah!&quot;;
</code></pre>
<h3 id="operators-2"><a class="header" href="#operators-2">Operators</a></h3>
<p><code>==</code>, <code>!=</code>,<code>+</code></p>
<h3 id="methods-3"><a class="header" href="#methods-3">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: Bool) -&gt; ByteArray;

func encode_utf8(self: Bool) -&gt; String;
</code></pre>
<h3 id="internal-namespace-2"><a class="header" href="#internal-namespace-2">Internal Namespace</a></h3>
<p><code>__helios__string</code></p>
<h2 id="bytearray-1"><a class="header" href="#bytearray-1">ByteArray</a></h2>
<hr />
<p>This represents an array of bytes.</p>
<pre><code class="language-rust  noplaypen">example: ByteArray = #213212;
</code></pre>
<h3 id="operators-3"><a class="header" href="#operators-3">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>+</code></p>
<h3 id="getters"><a class="header" href="#getters">Getters</a></h3>
<p><code>.length</code>, returns the length of the <code>ByteArray</code>.</p>
<h3 id="methods-4"><a class="header" href="#methods-4">Methods:</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: ByteArray) -&gt; ByteArray;

func length(self: String) -&gt; Int;

// @returns The SHA2-256 hash of the ByteArray
func sha2(self: ByteArray) -&gt; ByteArray;

// @returns The SHA3-256 hash of the ByteArray
func sha3(self: ByteArray) -&gt; ByteArray;

// @returns The Blake2b256 hash of the ByteArray
func blake2b(self: ByteArray) -&gt; ByteArray;

func decode_utf8(self: ByteArray) -&gt; String;

func show(self: ByteArray) -&gt; String;
</code></pre>
<h3 id="internal-namespace-3"><a class="header" href="#internal-namespace-3">Internal Namespace</a></h3>
<p><code>__helios__bytearray</code></p>
<h2 id="list-a-1"><a class="header" href="#list-a-1">List ([]a)</a></h2>
<hr />
<p>This is type a linked-list.</p>
<pre><code class="language-go  playpen">example: []Int = []Int{1, 2, 3, 4, 5};
</code></pre>
<h3 id="associated-functions-1"><a class="header" href="#associated-functions-1">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func new[a]() -&gt; []a;
</code></pre>
<h3 id="operators-4"><a class="header" href="#operators-4">Operators</a></h3>
<p><code>==</code>, <code>!=</code>,<code>__add</code></p>
<h3 id="getters-1"><a class="header" href="#getters-1">Getters</a></h3>
<pre><code class="language-go  noplaypen">// @returns The length of the list.
func length(self: []a) -&gt; Int;

// @returns The element at the front of the list
// @notice Throws an error if the list is empty.
func head[a](self: []a) -&gt; a;

// @returns The element at the end of the list.
// @notice Throws an error if the list is empty.
func tail[a](self: []a) -&gt; a;
</code></pre>
<h3 id="methods-5"><a class="header" href="#methods-5">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: []a) -&gt; ByteArray;

// @returns 'true' if the list is empty.
func is_empty(self: []a) -&gt; Bool;

// @returns The element the index in the list.
// @notice Throws an error if the list is too short.
func get[a](self: []a, index: Int) -&gt; a;

// @returns A new list with the item prepended at the front of the list.
func prepend[a](self: []a, item: a) -&gt; []a;

// @return 'true' if any of the items in the list satisfy the predicate.
func any[a](self: []a, predicate: (a) -&gt; Bool) -&gt; Bool;

// @return 'true' if all of the items in the list satisfy the predicate.
func all[a](self: []a, predicate: (a) -&gt; Bool) -&gt; Bool;

// @return The first element in the list that satisfies the predicate.
// @notice Throws an error is no element satisfies the predicate.
func find[a](self: []a, predicate: (a) -&gt; Bool) -&gt; a;

// @returns A list of all the elements in the list that satisfy the predicate.
func filter[a](self: []a, predicate: (a) -&gt; Bool) -&gt; []a;

// @returns Folds a list into a single value by continuosly applying the binary
//         function to the elements of the list.
func fold[a, b](self: []a, binary: (b, a) -&gt; b) -&gt; b;

// @returns The original list list with the transformation function called on
//          all it's elements.
func map[a, b](self: []a, transformation: (a) -&gt; b) -&gt; []b;
</code></pre>
<h3 id="internal-namespace-4"><a class="header" href="#internal-namespace-4">Internal Namespace</a></h3>
<p><code>__helios__list</code></p>
<h2 id="mapab"><a class="header" href="#mapab">Map[a,b]</a></h2>
<hr />
<p>This is type is a Hashmap like <code>Map</code> in Haskell or Dictionaries in Python. It's used to store key-value pairs.</p>
<pre><code class="language-go  noplaypen">my_map = Map[String]Int{&quot;zero&quot;: 0, &quot;one&quot;: 1, &quot;two&quot;: 2};
print(my_map.get(&quot;zero&quot;).show()); // prints '0'
</code></pre>
<h3 id="operators-5"><a class="header" href="#operators-5">Operators</a></h3>
<p><code>==</code>,<code>!=</code></p>
<h3 id="methods-6"><a class="header" href="#methods-6">Methods</a></h3>
<pre><code class="language-go  noplaypen">// @returns The Value in the map for the given key.
// @notice  Throws an error if the value isn't in the map.
func get[a, b](self: Map[a, b], key: a) -&gt; b;

// @returns 'true' if all the pairs satisfy the predicate.
func all[a, b](self: Map[a, b], predicate: (a, b) -&gt; Bool) -&gt; Bool

// @returns 'true' if all the pairs satisfy the predicate.
func any[a, b](self: Map[a, b], predicate: (a, b) -&gt; Bool) -&gt; Bool

func serialize(self: Map[a, b]) -&gt; ByteArray
</code></pre>
<p><code>serialize</code></p>
<h3 id="internal-namespace-5"><a class="header" href="#internal-namespace-5">Internal Namespace</a></h3>
<p><code>__helios__map</code></p>
<h2 id="optiona-1"><a class="header" href="#optiona-1">Option[a]</a></h2>
<hr />
<p><code>Option[a]</code> is an enum used to represent an optional value.</p>
<pre><code class="language-rust  noplaypen">enum Option[a] {
    Some { some: a }
    None
}

example_1: Option[Int] = Option::Some{42};
example_2: Option[Int] = Option::None;
</code></pre>
<h3 id="operators-6"><a class="header" href="#operators-6">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-7"><a class="header" href="#methods-7">Methods:</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: Option[a]) -&gt; ByteArray;
</code></pre>
<h3 id="internal-namespace-6"><a class="header" href="#internal-namespace-6">Internal Namespace</a></h3>
<p><code>__helios__option</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="time-types"><a class="header" href="#time-types">Time Types</a></h1>
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<hr />
<p>Represents time in POSIX format.</p>
<h3 id="associated-functions-2"><a class="header" href="#associated-functions-2">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func new(raw: Int) -&gt; Time;
</code></pre>
<h3 id="operators-7"><a class="header" href="#operators-7">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>+</code>, <code>-</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code></p>
<h3 id="methods-8"><a class="header" href="#methods-8">Methods</a></h3>
<p>serialize, show</p>
<h3 id="internal-namespace-7"><a class="header" href="#internal-namespace-7">Internal Namespace</a></h3>
<p><code>__helios__time</code></p>
<h2 id="duration"><a class="header" href="#duration">Duration</a></h2>
<hr />
<p>The <code>Duration</code> type represents as you've probably guessed a duration of time.
<code>Time</code> can be thought of as a vector quantity with direction, while <code>Duration</code> is a scalar quantity only having magnitude.</p>
<h3 id="associated-functions-3"><a class="header" href="#associated-functions-3">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func new(raw: Int) -&gt; Duration;
</code></pre>
<h3 id="operators-8"><a class="header" href="#operators-8">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>+</code>, <code>-</code>, <code>__mul</code>, <code>__div</code>, ``, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code></p>
<h3 id="methods-9"><a class="header" href="#methods-9">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: Time) -&gt; ByteArray
</code></pre>
<h3 id="internal-namespace-8"><a class="header" href="#internal-namespace-8">Internal Namespace</a></h3>
<p><code>__helios__duration</code></p>
<h2 id="timerange"><a class="header" href="#timerange">TimeRange</a></h2>
<hr />
<p>This represents a range of time using a pair of <code>Time</code> values.</p>
<h3 id="associated-functions-4"><a class="header" href="#associated-functions-4">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">// Represents TimeRange starting from positive to negative infinity.
// It contains all possible Time values.
const ALWAYS: TimeRange

// Represents TimeRange starting from negative to positive infinity.
// It contains nothing as it's impossible.
const NEVER: TimeRange

// @returns A TimeRange that contains all Time values from 'start' onwards.
func from(start: Time) -&gt; TimeRange;

// @returns A TimeRange that contains all Time values before 'start' up to 'start'.
func to(end: Time) -&gt; TimeRange;
</code></pre>
<h3 id="operators-9"><a class="header" href="#operators-9">Operators</a></h3>
<p><code>==</code>,<code>!=</code></p>
<h3 id="methods-10"><a class="header" href="#methods-10">Methods</a></h3>
<pre><code class="language-go  noplaypen">// @returns The start of TimeRange.
func get_start(self: TimeRange) -&gt; Time;

// @returns 'true' if self contains the 'other' TimeRange
func contains(self: TimeRange, other: TimeRange) -&gt; Bool;

// @returns 'true' if 'other' TimeRange is after 

func serialize(self: TimeRange) -&gt; Time;
</code></pre>
<h3 id="internal-namespace-9"><a class="header" href="#internal-namespace-9">Internal Namespace</a></h3>
<p><code>__helios__timerange</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cryptography-types"><a class="header" href="#cryptography-types">Cryptography Types</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="native-asset-types"><a class="header" href="#native-asset-types">Native-Asset Types</a></h1>
<p>Helios uses the <code>AssetClass</code> and <code>Value</code> types to represent Cardano Native-Assets.</p>
<h2 id="assetclass-1"><a class="header" href="#assetclass-1">AssetClass</a></h2>
<hr />
<p>Represents a unique token on the blockchain using the hash of it's minting policy and it's token name.</p>
<pre><code class="language-rust  noplaypen">struct AssetClass {
    policy_hash: MintingPolicyHash
    token_name: String
}
</code></pre>
<h3 id="associated-functions-5"><a class="header" href="#associated-functions-5">Associated Functions</a></h3>
<pre><code class="language-rust  noplaypen">const ADA: AssetClass;

// @returns a 
func new(policy_hash: ByteArray, token_name: ByteArray) -&gt; AssetClass;
</code></pre>
<h3 id="operators-10"><a class="header" href="#operators-10">Operators</a></h3>
<p><code>==</code>,<code>!=</code></p>
<h3 id="methods-11"><a class="header" href="#methods-11">Methods</a></h3>
<p><code>serialize</code></p>
<h3 id="internal-namespace-10"><a class="header" href="#internal-namespace-10">Internal Namespace</a></h3>
<p><code>__helios__assetclass</code></p>
<h2 id="value-1"><a class="header" href="#value-1">Value</a></h2>
<hr />
<p>The <code>Value</code> type represents a <strong>token bundle</strong> using a map of <code>AssetClass</code>es to amounts <code>Int</code>,</p>
<pre><code class="language-rust  noplaypen">struct Value {..}
</code></pre>
<h3 id="associated-functions-6"><a class="header" href="#associated-functions-6">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">// An empty Value
const ZERO: Value;

// @returns A Value containing 'amount' number of lovelaces.
func lovelace(amount: Int) -&gt; Value

// @returns A Value containing 'amount' number of the given 'asset_class'
func new(asset_class: AssetClass, amount: Int) -&gt; Value
</code></pre>
<h3 id="operators-11"><a class="header" href="#operators-11">Operators</a></h3>
<p><code>==</code>, <code>!=</code>, <code>+</code>, <code>-</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code>, <code>&lt;</code></p>
<h3 id="methods-12"><a class="header" href="#methods-12">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: Value) -&gt; ByteArray

func is_zero(self: Value) -&gt; Bool

func get(self: Value, asset_class) -&gt; Int

func contains(self: Value, other_value: Value) -&gt; Bool

// Hidden
// TODO
func get_map_keys()
func merge_map_key()
func get_inner_map()
func get_inner_map_int() 
func add_or_subtract_inner() 
func add_or_subtract() 
func compare_inner()
func compare()
</code></pre>
<h3 id="internal-namespace-11"><a class="header" href="#internal-namespace-11">Internal Namespace</a></h3>
<p><code>__helios__value</code></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="helios-builtins-1"><a class="header" href="#helios-builtins-1">Helios Builtins</a></h1>
<h2 id="pubkeyhash-validatorhash-mintingpolicyhash-datumhash"><a class="header" href="#pubkeyhash-validatorhash-mintingpolicyhash-datumhash">PubKeyHash, ValidatorHash, MintingPolicyHash, DatumHash</a></h2>
<hr />
<p>These are type-safe wrappers around the <code>ByteArray</code> type that represent the hash of
a public key, validator script, minting policy or datum.</p>
<h3 id="associated-functions-7"><a class="header" href="#associated-functions-7">Associated Functions</a></h3>
<pre><code class="language-go  playpen">func new(bytes: ByteArray) -&gt; PubKeyHash
</code></pre>
<h3 id="operators-12"><a class="header" href="#operators-12">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-13"><a class="header" href="#methods-13">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self) -&gt; ByteArray

func show(self) -&gt; String
</code></pre>
<h3 id="internal-namespace-12"><a class="header" href="#internal-namespace-12">Internal Namespace</a></h3>
<p><code>__helios__hash</code></p>
<h2 id="scriptcontext"><a class="header" href="#scriptcontext">ScriptContext</a></h2>
<hr />
<p>The <code>ScriptContext</code> type represents contains all the metadata related to a signed Cardano transaction.
It's just a wrapper around the <code>Tx</code> type with some extra methods.</p>
<pre><code class="language-go  noplaypen">struct ScriptContext {
    tx: Tx,
}
</code></pre>
<h3 id="operators-13"><a class="header" href="#operators-13">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-14"><a class="header" href="#methods-14">Methods</a></h3>
<pre><code class="language-go  noplaypen">// @returns The ScriptContext serialized into bytes.
func serialize(self: ScriptContext) -&gt; ByteArray;

// ! UNSURE
// @returns The TxOutputId of t
func get_spending_purpose_output_id(self: ScriptContext) -&gt; TxOutputId;

// @returns The ValidatorHash of the validator script being evaluated.
func get_current_validator_hash(self: ScriptContext) -&gt; ValidatorHash;

// @returns The MintingPolicyHash of the minting policy being evaluated.
func get_current_minting_policy_hash(self: ScriptContext) -&gt; MintingPolicyHash;

// @returns the TxInput locked by the validator script being evaluated.
func get_current_input(self: ScriptContext) -&gt; TxInput;
</code></pre>
<h3 id="internal-namespace-13"><a class="header" href="#internal-namespace-13">Internal Namespace</a></h3>
<p><code>__helios__scriptcontext</code></p>
<h2 id="tx-1"><a class="header" href="#tx-1">Tx</a></h2>
<hr />
<p>This type stores the data related to a signed transaction.</p>
<pre><code class="language-rust  noplaypen">struct Tx {
    id: TxId                     // Transaction ID
    inputs: []TxInputs           // Transactin Inputs
    outputs: []TxOutputs         // Transaction Outputs
    fee: Value                   // Fee paid for this transaction
    minted: Value                // Value minted by this transaction
    time_range: TimeRange        // Valid Time Range of a transaction
    signatories: []PubKeyHash    // signatories of the transaction
}
</code></pre>
<h3 id="operators-14"><a class="header" href="#operators-14">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-15"><a class="header" href="#methods-15">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: Tx) -&gt; ByteArray;

// @returns The current POSIX time.
func now(self: Tx) -&gt; Time; 

// @returns true if the transaction was signed by pubkeyhash.
func is_signed_by(self: Tx, pubkeyhash: PubKeyHash) -&gt; Bool;

// @returns The Datum Hash of the UTXO guarded by the script.
func find_datum_hash(self: Tx) -&gt; ByteArray;

// ! UNSURE
// @returns The TxOutputs sent to an address.
func outputs_sent_to(self: Tx, addr: PubKeyHash) -&gt; []TxOutput;

// ! UNSURE
// @returns The TxOutputs locked by a script.
func outputs_locked_by(self: Tx, script_hash: ScriptHash) -&gt; []TxOutput;

// ! UNSURE
// @returns The Value sent to an address.
func value_sent_to(self: Tx, addr: PubKeyHash) -&gt; Value;

// ! UNSURE
// @returns The Value locked by a script_hash.
func value_locked_by(self: Tx, script_hash: ScriptHash) -&gt; Value;

// ! UNSURE
// @returns The Value locked by datum_hash.
func value_locked_by_datum(self: Tx, datum_hash: DatumHash) -&gt; Value
</code></pre>
<h3 id="internal-namespace-14"><a class="header" href="#internal-namespace-14">Internal Namespace</a></h3>
<p><code>__helios__tx</code></p>
<h2 id="txid"><a class="header" href="#txid">TxId</a></h2>
<hr />
<p>This is a type-safe wrapper around the <code>ByteArray</code></p>
<pre><pre class="playground"><code class="language-rust  playpen">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TxId {...}
<span class="boring">}
</span></code></pre></pre>
<h3 id="operators-15"><a class="header" href="#operators-15">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-16"><a class="header" href="#methods-16">Methods</a></h3>
<p><code>serialize</code></p>
<h3 id="internal-namespace-15"><a class="header" href="#internal-namespace-15">Internal Namespace</a></h3>
<p><code>__helios__txid</code></p>
<h2 id="txinput-1"><a class="header" href="#txinput-1">TxInput</a></h2>
<hr />
<p>This type represents a <strong>Transaction Input</strong>.</p>
<pre><code class="language-rust  noplaypen">struct TxInput {
    output_id: TxOutputId,
    output: TxOutput
}
</code></pre>
<h3 id="operators-16"><a class="header" href="#operators-16">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-17"><a class="header" href="#methods-17">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: TxInput) -&gt; ByteArray
</code></pre>
<h3 id="internal-namespace-16"><a class="header" href="#internal-namespace-16">Internal Namespace</a></h3>
<p><code>__helios__txinput</code></p>
<h2 id="txoutput-1"><a class="header" href="#txoutput-1">TxOutput</a></h2>
<hr />
<p>This type represents a <strong>Transaction Output</strong>.</p>
<pre><code class="language-go  noplaypen">struct TxOutput {
    //! UNSURE
    address: Address
    value: Value
    datum_hash: ByteArray
}
</code></pre>
<h3 id="operators-17"><a class="header" href="#operators-17">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-18"><a class="header" href="#methods-18">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: TxOutput) -&gt; ByteArray

// Hidden
func get_datum_hash(self: TxOutput) -&gt; DatumHash
</code></pre>
<h3 id="internal-namespace-17"><a class="header" href="#internal-namespace-17">Internal Namespace</a></h3>
<p><code>__helios__txoutput</code></p>
<h2 id="txoutputid"><a class="header" href="#txoutputid">TxOutputId</a></h2>
<hr />
<p>This type is a unique ID for a UTXO (Unspent Transaction Output).
It's composed of the <strong>Transaction ID</strong> (<code>TxId</code>) of the transaction that created the UTXO and the index (<code>Int</code>) of the UTXO in the outputs of the transaction.</p>
<pre><code class="language-go  noplaypen">struct TxOutputId {
    tx_id: TxId
    index: Int
}
</code></pre>
<h3 id="associated-functions-8"><a class="header" href="#associated-functions-8">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">func new(tx_id: TxId, index: Int) -&gt; TxOutputId
</code></pre>
<h3 id="operators-18"><a class="header" href="#operators-18">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-19"><a class="header" href="#methods-19">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: TxOutputId) -&gt; ByteArray
</code></pre>
<h3 id="internal-namespace-18"><a class="header" href="#internal-namespace-18">Internal Namespace</a></h3>
<p><code>__helios__txoutputid</code></p>
<h2 id="address"><a class="header" href="#address">Address</a></h2>
<hr />
<p>The <code>Address</code> type represents a cardano address.</p>
<pre><code class="language-rust  noplaypen">struct Address {
    credential: Credential
    staking_credential: StakingCredential
}
</code></pre>
<h3 id="operators-19"><a class="header" href="#operators-19">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-20"><a class="header" href="#methods-20">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: Address) -&gt; ByteArray

// Hidden      
// @returns 'true' if the Address is staked.
func is_staked(self: Address) -&gt; Bool
</code></pre>
<h3 id="internal-namespace-19"><a class="header" href="#internal-namespace-19">Internal Namespace</a></h3>
<p><code>__helios__address</code></p>
<h2 id="credential"><a class="header" href="#credential">Credential</a></h2>
<hr />
<p>The <code>Credential</code> type represents the an onchain credential which can be a <code>PubKeyHash</code> or a <code>ValidatorHash</code></p>
<pre><code class="language-rust  noplaypen">enum Credential {
    Pubkey { hash: PubKeyHash }
    Validator { hash: ValidatorHash }
}
</code></pre>
<h3 id="operators-20"><a class="header" href="#operators-20">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-21"><a class="header" href="#methods-21">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: Credential) -&gt; ByteArray

// Hidden
// @returns 'true' if the Credential is a PubKeyHash
func is_pubkey(self: Credential) -&gt; Bool

// Hidden
// @returns 'true' if the Credential is a ValidatorHash
func is_validator(self: Credential) -&gt; Bool
</code></pre>
<h3 id="internal-namespace-20"><a class="header" href="#internal-namespace-20">Internal Namespace</a></h3>
<p><code>__helios__credential</code></p>
<h3 id="operators-21"><a class="header" href="#operators-21">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h2 id="stakingcredential"><a class="header" href="#stakingcredential">StakingCredential</a></h2>
<hr />
<p>// TODO Add internal of the <code>StakingCredential</code> type.</p>
<h3 id="operators-22"><a class="header" href="#operators-22">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-22"><a class="header" href="#methods-22">Methods</a></h3>
<pre><code class="language-go  noplaypen">func serialize(self: StakingCredential) -&gt; ByteArray
</code></pre>
<h3 id="internal-namespace-21"><a class="header" href="#internal-namespace-21">Internal Namespace</a></h3>
<p><code>__helios__stakingcredential</code></p>
<h2 id="common-hidden-from-user"><a class="header" href="#common-hidden-from-user">Common (hidden from user)</a></h2>
<h3 id="associated-functions-9"><a class="header" href="#associated-functions-9">Associated Functions</a></h3>
<pre><code class="language-go  noplaypen">// TODO Add documentation

func verbose_error()
func assert_constr_index()
func not()
func identity()
func serialize()
func is_in_bytearray_list()
func unbooldata()
func booldata()
func unstringdata()
func stringdata()
</code></pre>
<h3 id="operators-23"><a class="header" href="#operators-23">Operators</a></h3>
<p><code>==</code>, <code>!=</code></p>
<h3 id="methods-23"><a class="header" href="#methods-23">Methods</a></h3>
<p><code>__identity</code></p>
<h3 id="internal-namespace-22"><a class="header" href="#internal-namespace-22">Internal Namespace</a></h3>
<p><code>__helios__common</code></p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
