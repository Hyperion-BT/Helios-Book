<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>The Helios Programming Language</title>
        <meta name="robots" content="noindex" />


        <!-- Custom HTML head -->
        
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="The_Helios_Programming_Language.html"><strong aria-hidden="true">1.</strong> The Helios Programming Language</a></li><li class="chapter-item expanded "><a href="chapter_1/00_Basics_of_Helios.html"><strong aria-hidden="true">2.</strong> Chapter 1</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_1/01_Primitive_Types.html"><strong aria-hidden="true">2.1.</strong> Primitive Types</a></li><li class="chapter-item expanded "><a href="chapter_1/02_Control_Flow_and_Printing.html"><strong aria-hidden="true">2.2.</strong> Control Flow and Printing</a></li><li class="chapter-item expanded "><a href="chapter_1/03_Functions.html"><strong aria-hidden="true">2.3.</strong> Functions</a></li><li class="chapter-item expanded "><a href="chapter_1/04_Structs.html"><strong aria-hidden="true">2.4.</strong> Structs and Enums</a></li></ol></li><li class="chapter-item expanded "><a href="chapter_2/00_Blockchain_Programming_in_Helios.html"><strong aria-hidden="true">3.</strong> Chapter 2</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="chapter_2/01_The_EUTXO_Model.html"><strong aria-hidden="true">3.1.</strong> The EUTXO Model</a></li><li class="chapter-item expanded "><a href="chapter_2/02_Validator_Scripts.html"><strong aria-hidden="true">3.2.</strong> Validator Scripts</a></li><li class="chapter-item expanded "><a href="chapter_2/03_ScriptContext.html"><strong aria-hidden="true">3.3.</strong> The ScriptContext</a></li><li class="chapter-item expanded "><a href="chapter_2/04_vesting_contract.html"><strong aria-hidden="true">3.4.</strong> Project #1: Vesting Contract</a></li></ol></li><li class="chapter-item expanded "><a href="helios_builtins/Helios_Builtins.html"><strong aria-hidden="true">4.</strong> Helios Builtins</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky bordered">
                    <div class="left-buttons">
                        <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </button>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">The Helios Programming Language</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="the-helios-programming-language"><a class="header" href="#the-helios-programming-language">The Helios Programming Language</a></h1>
<p><a href="https://github.com/Hyperion-BT/Helios">Helios</a> is a DSL for writing smart contracts on the Cardano blockchain.
It's heavily inspired by Rust, Go and Sway.</p>
<h2 id="design-principles"><a class="header" href="#design-principles">Design Principles</a></h2>
<ul>
<li>Helios should be readable by almost any programmer.</li>
<li>There should be one and preferrably only one way to do everything.</li>
</ul>
<br/>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// All Helios programs begin with a script purpose.
validator always_true;

// The 'main' function contains the core validator logic.
func main(ctx: ScriptContext) -&gt; Bool {

    // Helios is an expression based language
    true
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chapter-2"><a class="header" href="#chapter-2">Chapter 2</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="section-11-primitive-types"><a class="header" href="#section-11-primitive-types">Section 1.1: Primitive Types</a></h1>
<h2 id="primitive-types"><a class="header" href="#primitive-types">Primitive Types</a></h2>
<p>Helios has five primitive types. All variables in Helios are <strong>immutable</strong>.</p>
<br/>
<table><thead><tr><th style="text-align: left">Name</th><th style="text-align: left">Literal</th><th style="text-align: left">Haskell Equivalent</th></tr></thead><tbody>
<tr><td style="text-align: left">Bool</td><td style="text-align: left"><code>true</code> or <code>false</code></td><td style="text-align: left"><code>Bool</code></td></tr>
<tr><td style="text-align: left">Int</td><td style="text-align: left"><code>42</code> or <code>0b11010011</code> or <code>0x7b</code></td><td style="text-align: left"><code>Integer</code> (unbounded integer)</td></tr>
<tr><td style="text-align: left">String</td><td style="text-align: left"><code>&quot;stringy&quot;</code> or <code>'stringier'</code></td><td style="text-align: left">?</td></tr>
<tr><td style="text-align: left">ByteArray</td><td style="text-align: left"><code>#thisisabytestring</code></td><td style="text-align: left"><code>ByteString</code></td></tr>
</tbody></table>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Boolean values
booly: Bool = true;

// Integers
inty: Int = 42;

// Strings
stringy: String = &quot;All your codes belongs to us.&quot;;

// BytesArrays
byte_array: ByteArray = #0x3132424;
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note:</strong> Helios has support for compile time constansts, constants are declared using the <code>const</code> keyword and must be named in all caps:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>const AGE: Int = 2132;
<span class="boring">}
</span></code></pre></pre>
<h2 id="list-a"><a class="header" href="#list-a">List ([]a)</a></h2>
<p>Helios has a list type list just like a the Haskell <code>List</code> type.
It's type signature is <code>[]a</code> where a is the type of items in the list.
Notably Helios list items aren't accessed using square brackets, <code>[]</code> for indexing instead the</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// A list of Integers
just_some_ints: []Int = []Int{1, 2, 3, 4, 5};
<span class="boring">}
</span></code></pre></pre>
<h3 id="useful-methods"><a class="header" href="#useful-methods">Useful Methods</a></h3>
<p>Helios lists have a lot of methods you'd normally find in other languages</p>
<pre><code class="language-golang">// List Methods.
fib_list: []Int = []Int{1, 1, 2, 3, 5};

trace(fib_list.len() != 5, &quot;This will print if the length of fib_list is 8.&quot;);

// Note: Throws error if index is out of range. 
trace(fib_list.get(4) != 5, &quot;This will print if the element at index 4 is 3.&quot;)

// Note: Throws an error if list is empty.
trace(fib_list.head() != 1, &quot;Gets the element at the front of the list.&quot;)

// Note: Throws an error if the list is empty.
trace(fib_list.tail() != 5, &quot;Returns the element at the end of the list.&quot;);

trace(fib_list.prepend(0) != []Int{0, 1, 1, 2, 3, 4, 5}, 
    &quot;Prepends item to the front of a list.&quot;)

trace(!([]Int{}).is_empty(), &quot;Checks if a list is empty.&quot;)
</code></pre>
<h3 id="map-wip"><a class="header" href="#map-wip">Map? [WIP]</a></h3>
<p>In future Helios might have a <code>Map</code> data structure just like in Haskell which would be a constant-time lookup, key-value pairs store.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="control-flow-printing-and-traces"><a class="header" href="#control-flow-printing-and-traces">Control Flow, Printing and Traces</a></h1>
<h2 id="control-flow"><a class="header" href="#control-flow">Control Flow</a></h2>
<p>Helios supports <code>if/else</code> statements.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if (true) {
    23
} else {
    42
}
<span class="boring">}
</span></code></pre></pre>
<p>In Helios <code>if</code>/<code>else</code> statements are expressions.
So the last expression is implicitly returned much like Rust and Ruby.
This is valid syntax: </p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>x: Int = if (true) {
            42
        } else {
            24
        };
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note</strong>: Compile-time constants can't be set to the result of an <code>if</code>/<code>else</code> expression.</p>
<h2 id="printing-and-traces"><a class="header" href="#printing-and-traces">Printing and Traces</a></h2>
<p>For debuggin purposes Helios has a <code>print</code> function.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>print(&quot;Imagine something cool.&quot;)
trace(21 &gt; 32, &quot;Should be true&quot;);
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note:</strong> Traces are <strong>horrible</strong> for production code as they lead to bloated validators.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="functions"><a class="header" href="#functions">Functions</a></h1>
<p>Functions are at the core of Helios as it's a functional language.
In Helios functions are declared using the <code>func</code> keyword.</p>
<pre><code class="language-go">func add(a: Int, b: Int) -&gt; Int {
    a + b  // There is no 'return' statement in Helios.
}

func fib(n: Int) -&gt; Int {
    // Helios is expression based so the branches of an if/else loop return expressions.
    if (n &lt; 1) {
        1
    } else {
        fib(n-1) + fib(n-2)
    }
}
</code></pre>
<h2 id="lambdaanonymous-functions"><a class="header" href="#lambdaanonymous-functions">Lambda/Anonymous Functions</a></h2>
<p>Helios also supports anonymous functions without needing the <code>func</code> keyword. This is for convenience when using higher order functions.</p>
<pre><code class="language-ts">// Anonymous functions with typing
is_even: (Int) -&gt; Bool = (n: Int) { (n % 2) == 0 };
</code></pre>
<p><strong>Note:</strong> Normal Functions should be chosen when possible for better clarity.</p>
<h2 id="first-class-functions"><a class="header" href="#first-class-functions">First-Class Functions</a></h2>
<p>Functions are <em>mostly</em> first-class citizens in Helios that means:</p>
<h3 id="1-functions-can-be-passed-as-arguments"><a class="header" href="#1-functions-can-be-passed-as-arguments">1. Functions can be passed as arguments</a></h3>
<pre><code class="language-ts">evens: []Int = ([]Int{1, 2, 3, 4, 5, 6}).filter(is_even); // [2, 4. 6]; 
</code></pre>
<h3 id="2-functions-can-be-returned-from-functions"><a class="header" href="#2-functions-can-be-returned-from-functions">2. Functions can be returned from functions</a></h3>
<pre><code class="language-ts">add: (Int) -&gt; (Int) -&gt; Int = (a: Int) { (b: Int) { a + b } };
</code></pre>
<p><strong>Note:</strong> I kind of partly lied when I told you that Helios has first-class functions,
functions can't be stored in lists or structs so they aren't <em><strong>completely</strong></em> first-class.</p>
<h2 id="example-code"><a class="header" href="#example-code">Example Code</a></h2>
<pre><code class="language-go">// Fibonnaci
func fib(n: Int) -&gt; Int {
    if (n &lt; 2) {
        n
    } else {
        fib(n-1) + fib(n-2)
    }
}

// A Collatz Sequence function :)
// A Collatz' sequence starts with a random number, n and follows
// very simple rules to decide the next number in the sequence.
// (1) If n is 1 the sequence is over.
// (2) If n is even the next number is n / 2.
// (3) If n is odd the next number is (n * 3) + 1.
func collatz(current: Int, accumulator: []Int) -&gt; []Int {
    if (current == 1) {
        // Rule (1)
        accumulator.prepend(current) 
    } else if (current % 2 == even) {
        // Rule (2)
        collatz((current / 2), accumulator.prepend(current))
    } else {
        // Rule (3)
        collatz(((current * 3) + 1), accumulator.prepend(current))      
    }
}

// More Lambdaassss
add: (Int, Int) -&gt; Int = (a: Int, b: Int) -&gt; { a + b };

// Please don't do this
fib_: (Int) -&gt; Int =  (n: Int) -&gt; {
    if (n &lt; 2) {
        n
    } else {
        fib_(n-1) + fib_(n-2)
    }
};
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="structs"><a class="header" href="#structs">Structs</a></h1>
<p>Structs in Helios are a lot like those in Rust and Records in Haskell. Structs are defined using the <code>struct</code> keyword. All fields in a Helios struct must be used or the compile will</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// Rational (fractional type)
struct Rational {
    top: Int,
    bottom: Int,
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="methods"><a class="header" href="#methods">Methods</a></h2>
<p>Structs in Helios have methods with syntax much like OOP languages. Methods are declared within <code>impl</code> blocks.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Rational {
    // Methods take an argument 'self' of the same type of the Struct

    func add(self: Rational, rhs: Rational) -&gt; Rational {
        top: Int = (self.top * rhs.bottom) + (rhs.top * self.bottom);
        bottom: Int = self.bottom * rhs.bottom;
    }
}

// Methods can be accessed using regular dot notation.
example_rational: Rational = Rational { top: 7, bottom: 21};
example-rational.add(example_rational)
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note:</strong> Methods cannot modify the struct as all <code>Helios</code> values are immutable. Methods are just syntactic sugar for regular functions, they are desugared into regular function calls:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>rational_1.add(rational_2); // Becomes __user__Rational_add(rational_1, rational_2)
<span class="boring">}
</span></code></pre></pre>
<h2 id="associated-functions-and-constants"><a class="header" href="#associated-functions-and-constants">Associated Functions and Constants</a></h2>
<p>Associated functions and constants are just like regular constants or functions but they're are namespaced by the Type. E.g Car::new(a, b, c).</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Rational {

    const RANDOM_CONSTANTS: Int = 1231;

    func new(top: Int, bottom: Int) -&gt; Rational {
        Rational { top: top, bottom: bottom }
    }

}

test_car: Car = Car::new(&quot;Model 3&quot;,  0, 0);
trace(Car::RANDOM_CONSTANTS == 1232, &quot;Never log&quot;);
<span class="boring">}
</span></code></pre></pre>
<h2 id="finished-code"><a class="header" href="#finished-code">Finished Code</a></h2>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Rational {
    top: Int,
    bottom: Int
}

impl Rational {
    const RANDOM_CONSTANTS: Int = 1231;

    func new(top: Int, bottom: Int) -&gt; Rational {
        Rational { top: top, bottom: bottom }
    }

    func add(self: Rational, rhs: Rational) -&gt; Rational {
        top: Int = (self.top * rhs.bottom) + (rhs.top * self.bottom);
        bottom: Int = self.bottom * rhs.bottom;
    }

}

rational_1: Rational = Rational::new(1, 5); // 1/5 or 0.2
rational_2: Rational = Rational::new(2, 5); // 2/5 or 0.4

res: Rational = rational_1.add(rational_2); // 3/5 or 0.6
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="blockchain-programming-in-helios"><a class="header" href="#blockchain-programming-in-helios">Blockchain Programming in Helios</a></h1>
<p>Helios <em>is</em> a DSL(Domain Specific Language) made for writing smart contracts.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-eutxo-model"><a class="header" href="#the-eutxo-model">The EUTXO Model</a></h1>
<p>This section wouldn't be possible without <a href="https://dav009.medium.com/learning-ergo-101-blockchain-paradigm-eutxo-c90b0274cf5e">this</a> great blog post by the awesome <a href="https://github.com/dav009">David Pryzbilla</a>.</p>
<h2 id="accounts-model-vs-eutxo-model"><a class="header" href="#accounts-model-vs-eutxo-model">Accounts Model vs EUTXO Model</a></h2>
<p>Smart contracts on Cardano are quite different from those on Ethereum.</p>
<h3 id="ethereum-style-smart-contracts-accounts-model"><a class="header" href="#ethereum-style-smart-contracts-accounts-model">Ethereum-style Smart Contracts (Accounts Model)</a></h3>
<p>Ethereum and other EVM-based blockchains use the Accounts model in which there are user wallets
and smart contracts are represented using <code>accounts</code> which are like objects stored onchain.</p>
<p>Contracts on Ethereum run via the EVM(Ethereum Virtual Machine),
the EVM can be thought of as a sort global onchain computer that smart contracts take turns to run on before being accepted onChain.</p>
<h3 id="components-of-a-utxo"><a class="header" href="#components-of-a-utxo">Components of a UTXO</a></h3>
<p>On EUTXO blockchain the ledger is made up of many UTXOs(Unspent Transcation Outputs). A UTXO has three components:</p>
<ul>
<li>tokens(Native Cardano Tokens</li>
<li>A Validator Script</li>
<li>A Datum.</li>
</ul>
<h4 id="datums"><a class="header" href="#datums">Datums</a></h4>
<p>These are data stored onChain associated with a particular UTXO. This is used to store state in Smart Contracts.
<strong>Note</strong>: To be exact on Cardano previously the Datum couldn't be stored onChain but as of PlutusV2 we now have actual onChain(inline) datums.</p>
<h4 id="validators"><a class="header" href="#validators">Validators</a></h4>
<p>A validators is a function that runs when a transaction attempts to spend a UTXO,
it returns a boolean which determines if the UTXO can be spent.
Validators contain the 'business logic' of a smart contract.</p>
<p>For example for a simple swap one could lock up some tokens in a UTXO with a validator that returns <code>true</code> if <strong>x</strong> amount of ADA is sent to your address.</p>
<p>A UTXO can only be spent once. In every transaction some UTXOs are destroyed,
<strong>Transaction Inputs (TxInputs)</strong> and new UTXOs are created, <strong>Transaction Inputs</strong>.
For a transaction to be valid it must satisfy some things:</p>
<ul>
<li>The total amount of tokens in the <strong>Transaction Inputs</strong> must be equal to those in the <strong>Transaction Ouputs</strong>.</li>
<li>The validators for all the <strong>Transaction Inputs</strong> must evaluate to <code>true</code>.</li>
</ul>
<h2 id="pros-and-cons-of-the-eutxo-model"><a class="header" href="#pros-and-cons-of-the-eutxo-model">Pros and Cons of the EUTXO Model</a></h2>
<h3 id="pros"><a class="header" href="#pros">Pros</a></h3>
<ul>
<li>
<p><strong>No Gas Fees</strong></p>
<p>EUTXO contracts are deterministic this means that you can verify if a transaction will suceed before posting it to the blockchain.
This is means no gas fees.</p>
</li>
<li>
<p><strong>Easier to Audit</strong></p>
<p>The <strong>locally-scoped</strong> aspect of EUTXO contracts reduces the potential attack surface by a lot.
This makes auditing way easier because you're auditing a <strong>single</strong> function.</p>
</li>
<li>
<p><strong>Concurrency</strong>
If designed properly EUTXO smart contracts paired with</p>
</li>
<li>
<p><strong>Better for Layer 2s</strong></p>
<p>The local nature of EUTXO lends itself well to building Layer 2 scaling solutions
such as sidechains(Milkomeda), state channels</p>
</li>
<li>
<p><strong>Simpler</strong>
Though not immediately obvious EUTXO smart contracts are often simpler than
an equivalent Solidity smart contract.</p>
</li>
<li>
<p><strong>No Reentrancy Attacks</strong>
Reentrancy attacks such as the <a href="https://en.wikipedia.org/wiki/The_DAO_(organization)">DAO hack</a>.</p>
</li>
</ul>
<h3 id="cons"><a class="header" href="#cons">Cons</a></h3>
<ul>
<li>
<p><strong>Concurrency Issues</strong>: If EUTXO contracts aren't designed properly they can encounter <strong>contention</strong>. <strong>Contention</strong> occurs when two transaction try
to spend the same UTXO, this isn't possible and leads to UX issues.
This is not usually an issue on Ethereum as the EVM usually handles ordering smart contract calls.</p>
<p>It's best to keep this in mind when designing smart contracts.</p>
</li>
</ul>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>It's totally normal if you're still confused about EUTXO it's not immediately intuitive.
In EUTXO smart contracts are more about specifying the requirements for tokens to be spent.
It is worth the extra effort as it often leads to contracts that are simpler overall.</p>
<p>I advise your read the article linked at the top even if you understand EUTXO, it's
written for the Ergo blockchain but a lot of the concepts carry over into cardano.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="validator-scripts"><a class="header" href="#validator-scripts">Validator Scripts</a></h1>
<p>In the last chapter we learnt that validators are functions that return a boolean (<code>true</code>  or <code>false</code>) when validating a transaction. In Helios validators are functions that take three arguments:</p>
<ul>
<li>The Redeemer: A piece of data attached to the transaction.</li>
<li>The Datum: Data stored onchain linked to the UTXO.</li>
<li>The ScriptContext: This is huge struct that holds data about the transaction spending the UTXO.</li>
</ul>
<p>The Redeemer and the Datum are user-defined but the <code>ScriptContext</code> struct is the same across all validators.</p>
<p>A simple validator</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>validator always_true;       // -------- (1)

struct DummyRedeemer {..}

struct DummyDatum {..}

func main(redeemer: DummyRedeemer, datum: DummyDatum, ctx: ScriptContext) -&gt; Bool {       
    ...
    true                     
}
<span class="boring">}
</span></code></pre></pre>
<p>(1) In Helios all scripts start with a  <strong>script purpose</strong> followed by the name of the script. There are three(3) script purposes currently:</p>
<ul>
<li><strong>validator</strong></li>
<li><strong>minting_policy</strong></li>
<li><strong>test</strong></li>
</ul>
<p>We will cover the latter two in later chapters.</p>
<p>The above validator could be rewritten as:</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>validator always_true;     

func main(ctx: ScriptContext) -&gt; Bool {        // -------- (2)
    ...
    true                     
}
<span class="boring">}
</span></code></pre></pre>
<p><strong>Note</strong>: The Helios compiler is smart enough to fill in a blank redeemer and datum when they are omitted(2).</p>
<p>The next page cover the ScriptContext.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="the-scriptcontext"><a class="header" href="#the-scriptcontext">The ScriptContext</a></h1>
<p>The ScriptContext is a wrapper around a <code>Tx</code> struct that holds some useful metadata.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct ScriptContext {
    tx: Tx
}

// Useful Methods
impl ScriptContext {
    // Serializes the ScriptContext to a ByteArray.
    func serialize(self) -&gt; ByteArray;

    // Get the hash of the Validator being evaluated.
    func get_current_validator_hash(self) -&gt; ByteArray;

    // Get the TxInput locked by the validator.
    func get_current_input(self) -&gt; TxInput;
}
<span class="boring">}
</span></code></pre></pre>
<h2 id="the-tx-struct"><a class="header" href="#the-tx-struct">The <code>Tx</code> Struct</a></h2>
<p>The <code>Tx</code> struct stores the data on the current transaction.</p>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Tx {
    id: TxId,
    inputs: []TxInput,          // Transaction inputs
    outputs: []TxOutput,        // Transaction outputs
    fee: Value,                 // Fee paid for this transaction
    time_range: TimeRange,      // Valid range for this transaction
    signatories: []PubKeyHash,  // Signatories of the transaction
}

impl Tx {
    func serialize(self) -&gt; ByteArray;

    func now(self) -&gt; Time;

    func outputs_sent_to(self, addr: PubKeyHash) -&gt; []TxOutput;

    func value_sent_to(self, addr: PubKeyHash) -&gt; Value;

    func is_signed_by(self, addr: PubKeyHash) -&gt; Bool;
}

<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct txInput {
    output_id: Int,
    output: TxOutput
}
<span class="boring">}
</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust">
<span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct TxOutput {
    address: PubKeyHash,
    value: Value,
    datum_hash:  ByteArray
}
<span class="boring">}
</span></code></pre></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="project-1-vesting-contract"><a class="header" href="#project-1-vesting-contract">Project #1: Vesting Contract</a></h1>
<div style="break-before: page; page-break-before: always;"></div><h1 id="helios-builtins"><a class="header" href="#helios-builtins">Helios Builtins</a></h1>
<h2 id="helios-operators"><a class="header" href="#helios-operators">Helios Operators</a></h2>
<table><thead><tr><th style="text-align: left">Operator</th><th style="text-align: left">Name</th></tr></thead><tbody>
<tr><td style="text-align: left"><code>==</code></td><td style="text-align: left"><code>__eq</code></td></tr>
<tr><td style="text-align: left"><code>!=</code></td><td style="text-align: left"><code>__neq</code></td></tr>
<tr><td style="text-align: left"><code>&gt;</code></td><td style="text-align: left"><code>__gt</code></td></tr>
<tr><td style="text-align: left"><code>&gt;=</code></td><td style="text-align: left"><code>__geq</code></td></tr>
<tr><td style="text-align: left"><code>&lt;</code></td><td style="text-align: left"><code>__lt</code></td></tr>
<tr><td style="text-align: left"><code>&lt;=</code></td><td style="text-align: left"><code>__leq</code></td></tr>
<tr><td style="text-align: left"><code>!</code></td><td style="text-align: left"><code>__not</code></td></tr>
<tr><td style="text-align: left"><code>and</code></td><td style="text-align: left"><code>__and</code></td></tr>
<tr><td style="text-align: left"><code>or</code></td><td style="text-align: left"><code>__or</code></td></tr>
</tbody></table>
<h2 id="int"><a class="header" href="#int">Int</a></h2>
<hr />
<h3 id="operators"><a class="header" href="#operators">Operators</a></h3>
<p><code>__eq</code>, <code>__neq</code>, <code>__neg</code>, <code>__pos</code>, <code>__add</code>, <code>__sub</code>, <code>__mul</code>, <code>__div</code>, <code>__mod</code>, <code>__geq</code>, <code>__gt</code>, <code>__leq</code>, <code>__lt</code></p>
<h3 id="methods-1"><a class="header" href="#methods-1">Methods</a></h3>
<pre><code class="language-go">func serialize(self: Int) -&gt; ByteArray;
func to_bool(self: Int) -&gt; Bool;
func show(self: Int) -&gt; String;
</code></pre>
<h3 id="internal-namespace"><a class="header" href="#internal-namespace">Internal Namespace</a></h3>
<p><code>__helios__int</code></p>
<h2 id="bool"><a class="header" href="#bool">Bool</a></h2>
<hr />
<h3 id="associated-functions"><a class="header" href="#associated-functions">Associated Functions</a></h3>
<pre><code class="language-go">func and(bool_1: Bool, bool_2: Bool) -&gt; Bool

func or(bool_1: Bool, bool_2: Bool) -&gt; Bool
</code></pre>
<h3 id="operators-1"><a class="header" href="#operators-1">Operators</a></h3>
<p><code>__eq</code>, <code>__neq</code>, <code>__not</code>, <code>__and</code> (desugars as <code>and</code>), <code>__or</code> (desugars as <code>or</code>)</p>
<h3 id="methods-2"><a class="header" href="#methods-2">Methods:</a></h3>
<pre><code class="language-go">func serialize(self: Bool) -&gt; ByteArray;

func to_int(self: Bool) -&gt; Int;

func show(self: Bool) -&gt; String;
</code></pre>
<h3 id="internal-namespace-1"><a class="header" href="#internal-namespace-1">Internal Namespace</a></h3>
<p><code>__helios__bool</code></p>
<h2 id="string"><a class="header" href="#string">String</a></h2>
<hr />
<h3 id="operators-2"><a class="header" href="#operators-2">Operators</a></h3>
<p><code>__eq</code>, <code>__neq</code>,<code>__add</code></p>
<h3 id="methods-3"><a class="header" href="#methods-3">Methods</a></h3>
<pre><code class="language-go">func serialize(self: Bool) -&gt; ByteArray;

func encode_utf8(self: Bool) -&gt; String;
</code></pre>
<h3 id="internal-namespace-2"><a class="header" href="#internal-namespace-2">Internal Namespace</a></h3>
<p><code>__helios__string</code></p>
<h2 id="bytearray"><a class="header" href="#bytearray">ByteArray</a></h2>
<hr />
<h3 id="operators-3"><a class="header" href="#operators-3">Operators</a></h3>
<p><code>__eq</code>, <code>__neq</code>,<code>__add</code> </p>
<h3 id="getters"><a class="header" href="#getters">Getters</a></h3>
<p><code>.length</code>, returns the length of the <code>ByteArray</code>.</p>
<h3 id="methods-4"><a class="header" href="#methods-4">Methods:</a></h3>
<pre><code class="language-go">func serialize(self: String) -&gt; ByteArray;

func length(self: String) -&gt; Int;

func sha2(self: String) -&gt; ByteArray;

func sha3(self: String) -&gt; ByteArray;

func blake2b(self: String) -&gt; ByteArray;

func decode_utf8(self: String) -&gt; String;

func show(self: String) -&gt; String;
</code></pre>
<h3 id="internal-namespace-3"><a class="header" href="#internal-namespace-3">Internal Namespace</a></h3>
<p><code>__helios__bytearray</code></p>
<h2 id="list-a-1"><a class="header" href="#list-a-1">List ([]a)</a></h2>
<h3 id="associated-functions-1"><a class="header" href="#associated-functions-1">Associated Functions</a></h3>
<pre><code class="language-go">func new[a]() -&gt; []a;
</code></pre>
<h3 id="operators-4"><a class="header" href="#operators-4">Operators:</a></h3>
<p><code>__eq</code>, <code>__neq</code>,<code>__add</code></p>
<h3 id="getters-1"><a class="header" href="#getters-1">Getters</a></h3>
<pre><code class="language-go">func lenght(self: []a) -&gt; Int;

// @returns The element at the front of the list
// @notice Throws an error if the list is empty.
func head[a](self: []a) -&gt; a;

// @returns The element at the end of the list.
// @notice Throws an error if the list is empty.
func tail[a](self: []a) -&gt; a;
</code></pre>
<h3 id="methods-5"><a class="header" href="#methods-5">Methods:</a></h3>
<pre><code class="language-go">func serialize(self: []a) -&gt; ByteArray;

func is_empty(self: []a) -&gt; Bool;

// @returns The element the index in the list.
// @notice Throws an error if the list is too short.
func get[a](self: []a, index: Int) -&gt; a;

// @returns A new list with the item prepended at the front of the list.
func prepend[a](self: []a, item: a) -&gt; []a;

// @return 'true' if any of the items in the list satisfy the predicate.
func any[a](self: []a, predicate: (a) -&gt; Bool) -&gt; Bool;

// @return 'true' if all of the items in the list satisfy the predicate.
func all[a](self: []a, predicate: (a) -&gt; Bool) -&gt; Bool;

// @return The first element in the list that satisfies the predicate.
// @notice Throws an error is no element satisfies the predicate.
func find[a](self: []a, predicate: (a) -&gt; Bool) -&gt; a;

//@returns A list of all the elements in the list that satisfy the predicate.
func filter[a](self: []a, predicate: (a) -&gt; Bool) -&gt; []a;

//@returns Folds a list into a single value by continuosly applying the binary
//         function to the elements of the list.
func fold[a, b](self: []a, binary: (b, a) -&gt; b) -&gt; b;

// @returns The original list list with the transformation function called on
//          all it's elements.
func map[a, b](self: []a, transformation: (a) -&gt; b) -&gt; []b;
</code></pre>
<h3 id="internal-namespace-4"><a class="header" href="#internal-namespace-4">Internal Namespace</a></h3>
<p><code>__helios__list</code></p>
<h2 id="map"><a class="header" href="#map">Map</a></h2>
<h3 id="operators-5"><a class="header" href="#operators-5">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="methods-6"><a class="header" href="#methods-6">Methods</a></h3>
<p><code>serialize</code></p>
<h3 id="internal-namespace-5"><a class="header" href="#internal-namespace-5">Internal Namespace</a></h3>
<p><code>__helios__map</code></p>
<h2 id="optiona"><a class="header" href="#optiona">Option[a]</a></h2>
<p><code>Option[a]</code> is an enum used to represent an optional value.</p>
<pre><code class="language-go">Option[a] {
    Some { a },
    None
}
</code></pre>
<h3 id="operators-6"><a class="header" href="#operators-6">Operators:</a></h3>
<p><code>__eq</code>,<code>__neq</code> </p>
<h3 id="methods-7"><a class="header" href="#methods-7">Methods:</a></h3>
<p><code>serialize</code></p>
<h3 id="internal-namespace-6"><a class="header" href="#internal-namespace-6">Internal Namespace</a></h3>
<p><code>__helios__option</code></p>
<h2 id="optionsome"><a class="header" href="#optionsome">Option::Some</a></h2>
<h3 id="associated-functions-2"><a class="header" href="#associated-functions-2">Associated Functions</a></h3>
<pre><code class="language-go">func new[a](value: a) -&gt; Option[a];
func cast[a](value: a) -&gt; Option[a];
</code></pre>
<h3 id="operators-7"><a class="header" href="#operators-7">Operators:</a></h3>
<p><code>__eq</code>,<code>__neq</code> </p>
<h3 id="getters-2"><a class="header" href="#getters-2">Getters</a></h3>
<pre><code class="language-go">// @returns The the value in a Some variant.
// @notice Throws an error if called on a None variant.
func value[a](self: Option[a]) -&gt; a;
</code></pre>
<h3 id="methods-8"><a class="header" href="#methods-8">Methods</a></h3>
<p>func serialize(self: Option[a]) -&gt; ByteArray;</p>
<h3 id="internal-namespace-7"><a class="header" href="#internal-namespace-7">Internal Namespace</a></h3>
<p><code>__helios__option__some</code></p>
<h2 id="optionnone"><a class="header" href="#optionnone">Option::None</a></h2>
<h3 id="associated-functions-3"><a class="header" href="#associated-functions-3">Associated Functions</a></h3>
<pre><code class="language-go">func new[a]() -&gt; Option[a];

// ! UNSURE
func cast[a]() -&gt; Option[a];
</code></pre>
<h3 id="operators-8"><a class="header" href="#operators-8">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="methods-9"><a class="header" href="#methods-9">Methods:</a></h3>
<pre><code class="language-go">func serialize(self: Option[a]) -&gt; ByteArray;
</code></pre>
<h3 id="internal-namespace-8"><a class="header" href="#internal-namespace-8">Internal Namespace</a></h3>
<p><code>__helios__option__none</code></p>
<h2 id="pubkeyhash-validatorhash-mintingpolicyhash-datumhash"><a class="header" href="#pubkeyhash-validatorhash-mintingpolicyhash-datumhash">PubKeyHash, ValidatorHash, MintingPolicyHash, DatumHash</a></h2>
<h3 id="associated-functions-4"><a class="header" href="#associated-functions-4">Associated Functions</a></h3>
<p>new</p>
<h3 id="operators-9"><a class="header" href="#operators-9">Operators:</a></h3>
<p><code>__eq</code>,<code>__neq</code> </p>
<h3 id="methods-10"><a class="header" href="#methods-10">Methods:</a></h3>
<p>serialize, show</p>
<h3 id="internal-namespace-9"><a class="header" href="#internal-namespace-9">Internal Namespace</a></h3>
<p><code>__helios__hash</code></p>
<h2 id="scriptcontext"><a class="header" href="#scriptcontext">ScriptContext</a></h2>
<h3 id="operators-10"><a class="header" href="#operators-10">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="getters-3"><a class="header" href="#getters-3">Getters</a></h3>
<pre><code class="language-go">struct ScriptContext {
    tx: Tx,
    ...
}
</code></pre>
<h3 id="methods-11"><a class="header" href="#methods-11">Methods</a></h3>
<pre><code class="language-go">func serialize(self: ScriptContext) -&gt; ByteArray;

// ! UNSURE
func get_spending_purpose_output_id(self: ScriptContext) -&gt; Int;

func get_current_validator_hash(self: ScriptContext) -&gt; ByteArray;

func get_current_minting_policy_hash(self: ScriptContext) -&gt; ByteArray;)

func get_current_input(self: ScriptContext) -&gt; TxInput;
</code></pre>
<h3 id="internal-namespace-10"><a class="header" href="#internal-namespace-10">Internal Namespace</a></h3>
<p><code>__helios__scriptcontext</code></p>
<h2 id="tx"><a class="header" href="#tx">Tx</a></h2>
<p>This struct stores the data related to a signed transaction.</p>
<h3 id="operators-11"><a class="header" href="#operators-11">Operators:</a></h3>
<p><code>__eq</code>,<code>__neq</code> </p>
<h3 id="getters-4"><a class="header" href="#getters-4">Getters</a></h3>
<pre><code class="language-go">struct Tx {
    id: TxId,                    // Transaction ID
    inputs: []TxInputs,          // Transactin Inputs
    outputs: []TxOutputs,        // Transaction Outputs
    fee: Value,                  // Fee paid for this transaction
    minted: Value,               // Value minted by this transaction
    time_range: TimeRange,       // Valid Time Range of a transaction
    signatories: []PubKeyHash    // signatories of the transaction
}
</code></pre>
<h3 id="methods-12"><a class="header" href="#methods-12">Methods</a></h3>
<pre><code class="language-go">func serialize(self: Tx) -&gt; ByteArray;

// @returns The current POSIX time.
func now(self: Tx) -&gt; Time; 

// @returns true if the transaction was signed by pubkeyhash.
func is_signed_by(self: Tx, pubkeyhash: PubKeyHash) -&gt; Bool;

// @returns The Datum Hash of the UTXO guarded by the script.
func find_datum_hash(self: Tx) -&gt; ByteArray;

// ! UNSURE
// @returns The TxOutputs sent to an address.
func outputs_sent_to(self: Tx, addr: PubKeyHash) -&gt; []TxOutput;

// ! UNSURE
// @returns The TxOutputs locked by a script.
func outputs_locked_by(self: Tx, script_hash: ScriptHash) -&gt; []TxOutput;

// ! UNSURE
// @returns The Value sent to an address.
func value_sent_to(self: Tx, addr: PubKeyHash) -&gt; Value;

// ! UNSURE
// @returns The Value locked by a script_hash.
func value_locked_by(self: Tx, script_hash: ScriptHash) -&gt; Value;

// ! UNSURE
// @returns The Value locked by datum_hash.
func value_locked_by_datum(self: Tx, datum_hash: Datum)
</code></pre>
<h3 id="internal-namespace-11"><a class="header" href="#internal-namespace-11">Internal Namespace</a></h3>
<p><code>__helios__tx</code></p>
<h2 id="txid"><a class="header" href="#txid">TxId</a></h2>
<h3 id="operators-12"><a class="header" href="#operators-12">Operators:</a></h3>
<p><code>__eq</code>,<code>__neq</code> </p>
<h3 id="methods-13"><a class="header" href="#methods-13">Methods:</a></h3>
<p>serialize</p>
<h3 id="internal-namespace-12"><a class="header" href="#internal-namespace-12">Internal Namespace</a></h3>
<p><code>__helios__txid</code> </p>
<h2 id="txinput"><a class="header" href="#txinput">TxInput</a></h2>
<h3 id="operators-13"><a class="header" href="#operators-13">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="getters-5"><a class="header" href="#getters-5">Getters</a></h3>
<pre><code class="language-go">struct TxInput {
    output_id: TxOutputId,
    output: TxOutput
}

</code></pre>
<h3 id="methods-14"><a class="header" href="#methods-14">Methods</a></h3>
<p>serialize</p>
<h3 id="internal-namespace-13"><a class="header" href="#internal-namespace-13">Internal Namespace</a></h3>
<p><code>__helios__txinput</code></p>
<h2 id="txoutput"><a class="header" href="#txoutput">TxOutput</a></h2>
<h3 id="operators-14"><a class="header" href="#operators-14">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="getters-6"><a class="header" href="#getters-6">Getters</a></h3>
<pre><code class="language-go">struct TxOutput {
    //! UNSURE
    address: Address,
    value: Value,
    datum_hash: ByteArray
}
</code></pre>
<h3 id="methods-15"><a class="header" href="#methods-15">Methods</a></h3>
<p>serialize
hidden:      get_datum_hash</p>
<h3 id="internal-namespace-14"><a class="header" href="#internal-namespace-14">Internal Namespace</a></h3>
<p><code>__helios__txoutput</code></p>
<h2 id="txoutputid"><a class="header" href="#txoutputid">Txoutputid</a></h2>
<h3 id="associated-functions-5"><a class="header" href="#associated-functions-5">Associated Functions</a></h3>
<p>// TODO
new</p>
<h3 id="operators-15"><a class="header" href="#operators-15">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="methods-16"><a class="header" href="#methods-16">Methods</a></h3>
<p>serialize</p>
<h3 id="internal-namespace-15"><a class="header" href="#internal-namespace-15">Internal Namespace</a></h3>
<p><code>__helios__txoutputid</code></p>
<h2 id="address"><a class="header" href="#address">Address</a></h2>
<h3 id="operators-16"><a class="header" href="#operators-16">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code> </p>
<h3 id="getters-7"><a class="header" href="#getters-7">Getters</a></h3>
<pre><code class="language-go">struct Address {
    credential: Credential,
    staking_credential: StakingCredential
}
</code></pre>
<h3 id="methods-17"><a class="header" href="#methods-17">Methods</a></h3>
<p>serialize
hidden:      is_staked</p>
<h3 id="internal-namespace-16"><a class="header" href="#internal-namespace-16">Internal Namespace</a></h3>
<p>__helios<code>__add</code>ress</p>
<h2 id="credential"><a class="header" href="#credential">Credential</a></h2>
<h3 id="operators-17"><a class="header" href="#operators-17">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="methods-18"><a class="header" href="#methods-18">Methods</a></h3>
<p>serialize
hidden:      is_pubkey, is_validator</p>
<h3 id="internal-namespace-17"><a class="header" href="#internal-namespace-17">Internal Namespace</a></h3>
<p><code>__helios__credential</code></p>
<h2 id="credentialpubkey"><a class="header" href="#credentialpubkey">Credential::PubKey</a></h2>
<h3 id="associated-functions-6"><a class="header" href="#associated-functions-6">Associated Functions</a></h3>
<p>// TODO
cast</p>
<h3 id="operators-18"><a class="header" href="#operators-18">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="getters-8"><a class="header" href="#getters-8">Getters</a></h3>
<pre><code class="language-go">enum Credential {
    PubKey { hash: PubKeyHash },
    ...
}
</code></pre>
<h3 id="methods-19"><a class="header" href="#methods-19">Methods</a></h3>
<p>serialize</p>
<h3 id="internal-namespace-18"><a class="header" href="#internal-namespace-18">Internal Namespace</a></h3>
<p><code>__helios__credential__pubkey</code></p>
<h2 id="credentialvalidator"><a class="header" href="#credentialvalidator">Credential::Validator</a></h2>
<h3 id="associated-functions-7"><a class="header" href="#associated-functions-7">Associated Functions</a></h3>
<p>cast</p>
<h3 id="operators-19"><a class="header" href="#operators-19">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="getters-9"><a class="header" href="#getters-9">Getters</a></h3>
<pre><code class="language-go">enum Credential {
    ...
    Validator { hash: ValidatorHash },
}
</code></pre>
<h3 id="methods-20"><a class="header" href="#methods-20">Methods</a></h3>
<p>serialize</p>
<h3 id="internal-namespace-19"><a class="header" href="#internal-namespace-19">Internal Namespace</a></h3>
<p><code>__helios__credential__validator</code></p>
<h2 id="stakingcredential"><a class="header" href="#stakingcredential">StakingCredential</a></h2>
<h3 id="operators-20"><a class="header" href="#operators-20">Operators:</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="methods-21"><a class="header" href="#methods-21">Methods</a></h3>
<p>serialize</p>
<h3 id="internal-namespace-20"><a class="header" href="#internal-namespace-20">Internal Namespace</a></h3>
<p><code>__helios__stakingcredential</code></p>
<h2 id="time"><a class="header" href="#time">Time</a></h2>
<p>Represents time in POSIX format.</p>
<h3 id="associated-functions-8"><a class="header" href="#associated-functions-8">Associated Functions</a></h3>
<pre><code class="language-go">func new(raw: Int) -&gt; Time;
</code></pre>
<h3 id="operators-21"><a class="header" href="#operators-21">Operators</a></h3>
<p><code>__eq</code>, <code>__neq</code>, <code>__add</code>, <code>__sub</code>, <code>__geq</code>, <code>__gt</code>, <code>__leq</code>, <code>__lt</code></p>
<h3 id="methods-22"><a class="header" href="#methods-22">Methods</a></h3>
<p>serialize, show</p>
<h3 id="internal-namespace-21"><a class="header" href="#internal-namespace-21">Internal Namespace</a></h3>
<p><code>__helios__time</code></p>
<h2 id="duration"><a class="header" href="#duration">Duration</a></h2>
<p>// FIX DEFINITION
<code>Time</code> can be thought of as a vector quantity with direction, while <code>Duration</code> is a scalar quantity only having magnitude.</p>
<h3 id="associated-functions-9"><a class="header" href="#associated-functions-9">Associated Functions</a></h3>
<pre><code class="language-go">func new(raw: Int) -&gt; Duration;
</code></pre>
<h3 id="operators-22"><a class="header" href="#operators-22">Operators</a></h3>
<p><code>__eq</code>, <code>__neq</code>, <code>__add</code>, <code>__sub</code>, <code>__mul</code>, <code>__div</code>, ``, <code>__geq</code>, <code>__gt</code>, <code>__leq</code>, <code>__lt</code> </p>
<h3 id="methods-23"><a class="header" href="#methods-23">Methods</a></h3>
<p>serialize</p>
<h3 id="internal-namespace-22"><a class="header" href="#internal-namespace-22">Internal Namespace</a></h3>
<p><code>__helios__duration</code></p>
<h2 id="timerange"><a class="header" href="#timerange">TimeRange</a></h2>
<h3 id="operators-23"><a class="header" href="#operators-23">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="methods-24"><a class="header" href="#methods-24">Methods</a></h3>
<pre><code class="language-go">// @returns The start of TimeRange.
func get_start(self: TimeRange) -&gt; Time;
</code></pre>
<p>serialize</p>
<h3 id="internal-namespace-23"><a class="header" href="#internal-namespace-23">Internal Namespace</a></h3>
<p><code>__helios__timerange</code></p>
<h2 id="assetclass"><a class="header" href="#assetclass">AssetClass</a></h2>
<h3 id="associated-functions-10"><a class="header" href="#associated-functions-10">Associated Functions</a></h3>
<p>// TODO</p>
<pre><code class="language-go"></code></pre>
<p>ada, new</p>
<h3 id="operators-24"><a class="header" href="#operators-24">Operators:</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="methods-25"><a class="header" href="#methods-25">Methods</a></h3>
<p>serialize</p>
<h3 id="internal-namespace-24"><a class="header" href="#internal-namespace-24">Internal Namespace</a></h3>
<p><code>__helios__assetclass</code></p>
<h2 id="value"><a class="header" href="#value">Value</a></h2>
<h3 id="associated-functions-11"><a class="header" href="#associated-functions-11">Associated Functions</a></h3>
<p>// TODO
zero, lovelace, new</p>
<h3 id="operators-25"><a class="header" href="#operators-25">Operators</a></h3>
<p><code>__eq</code>, <code>__neq</code>, <code>__add</code>, <code>__sub</code>, <code>__geq</code>, <code>__gt</code>, <code>__leq</code>, <code>__lt</code></p>
<h3 id="methods-26"><a class="header" href="#methods-26">Methods</a></h3>
<p>serialize, is_zero, get
hidden:      get_map_keys, merge_map_keys, get_inner_map, get_inner_map_int, add_or_subtract_inner, add_or_subtract, compare_inner, compare</p>
<h3 id="internal-namespace-25"><a class="header" href="#internal-namespace-25">Internal Namespace</a></h3>
<p><code>__helios__value</code></p>
<h2 id="common-hidden-from-user"><a class="header" href="#common-hidden-from-user">common (hidden from user)</a></h2>
<h3 id="associated-functions-12"><a class="header" href="#associated-functions-12">Associated Functions</a></h3>
<p>// TODO
verbose_error, assert_constr_index, not, identity, serialize, is_in_bytearray_list
unbooldata, booldata, unstringdata, stringdata</p>
<h3 id="operators-26"><a class="header" href="#operators-26">Operators</a></h3>
<p><code>__eq</code>,<code>__neq</code></p>
<h3 id="methods-27"><a class="header" href="#methods-27">Methods</a></h3>
<p>__identity</p>
<h3 id="internal-namespace-26"><a class="header" href="#internal-namespace-26">Internal Namespace</a></h3>
<p>__helios__common</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script type="text/javascript">
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>



        <script type="text/javascript">
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->

        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </body>
</html>
